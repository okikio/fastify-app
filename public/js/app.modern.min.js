let {
  assign,
  keys,
  values,
  getOwnPropertyNames
} = Object;
let {
  isArray,
  from,
  of
} = Array; // Create an array of values that two array share in common

let _intersect = (a, b) => a.filter(val => b.includes(val)); // Capitalize strings

let _capital = val => val[0].toUpperCase() + val.slice(1); // Test the type of a value

let _is = (val, type) => typeof val == type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len == 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: val => !_is(val, "undefined"),
  win: val => val && val.window,
  undef: _type("undefined"),
  bool: _type("boolean"),
  fn: _type("function"),
  obj: _type("object"),
  str: _type("string"),
  nul: _type("null"),
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (_is.not("fn", fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
}; // Argument names

let _argNames = fn => {
  let args = fn.toString().match(/^[\s(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',');
  return args.length == 1 && !args[0] ? [] : args;
}; // Get or set a value in an Object, based on it's path

let _path = (obj, path, val) => {
  path = path.toString().split(/[.,]/g);

  if (_is.def(val)) {
    if (path.length > 1) {
      _path(obj[path.shift()], path, val);
    } else {
      obj[path[0]] = val;
    }

    return val;
  } else {
    path.forEach(_val => {
      obj = obj[_val];
    });
  }

  return obj;
};
/* 
    Builds on path and adds more power, 
    * Allows for multiple paths one value
    * Using Objects as paths and setting the values individually
    * Access values as an Array, from multiple paths
*/

let _attr = (obj, path, val) => {
  if (_is.obj(path) && _is.not("arr", path)) {
    return assign(obj, path);
  } else if (_is.arr(path)) {
    if (_is.undef(val)) {
      return path.map(_key => _path(obj, _key));
    } else {
      path.forEach(_key => {
        _path(obj, _key, val);
      });
    }
  } else {
    return _path(obj, path, val);
  }

  return obj;
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

let _new = function (ctor, args) {
  let F = function () {
    return ctor.apply(this, args);
  };

  F.prototype = ctor.prototype;
  return new F();
};

/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.';
}
/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */


function getCutoff(array, value) {
  var length = array.length;

  for (var index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */


function createReplacer(replacer, circularReplacer) {
  var hasReplacer = typeof replacer === 'function';
  var hasCircularReplacer = typeof circularReplacer === 'function';
  var cache = [];
  var keys = [];
  return function replace(key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoff(cache, this);

        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys[keys.length] = key;
        var valueCutoff = getCutoff(cache, value);

        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=" + getReferenceKey(keys, valueCutoff) + "]";
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 *
 * @param the value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */


function stringify(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
}

var index_esm = /*#__PURE__*/Object.freeze({
    'default': stringify
});

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var stringify$1 = getCjsExportFromNamespace(index_esm);

let _stringify = obj => {
  let fns = [];
  let json = stringify$1(obj, (key, val) => {
    if (typeof val == "function") {
      fns.push(val.toString());
      return "_";
    }

    return val;
  }, 4);
  return json.replace(/"_"/g, () => fns.shift());
};

var stringify_1 = {
  stringify: stringify$1,
  _stringify
};
var stringify_3 = stringify_1._stringify;

let _attachProp = where => {
  let _prototype = where == "prototype";

  return (_obj, ...args) => {
    // If super class exists, set value of parent to `SuperClass` prototype
    let parent = _obj.SuperClass && _obj.SuperClass.prototype;
    args.forEach(function (val) {
      // Transform functions to Objects
      let obj = _fnval(val, [_obj, _obj.constructor], _prototype ? _obj.prototype : _obj); // Iterate through Object


      keys(obj).forEach(function (i) {
        let _val = obj[i],
            preVal = _val; // If a Parent Class is Present, Set any argument/params named `$super` to the `Parent`

        if (_is.fn(_val)) {
          if (_prototype && parent && _argNames(_val)[0] == "$super") {
            // Let the first argument be the original value
            _val = function (...args) {
              let parentFn = parent[i].bind(this);
              return preVal.call(this, parentFn, ...args);
            };
          } // For debugging purposes


          _val.valueOf = preVal.valueOf.bind(preVal);
          _val.toString = preVal.toString.bind(preVal);
        }

        (_prototype ? _obj.prototype : _obj)[i] = _val; // Redefinition Error Fix

        /* 
            Allows the use of `Object.defineProperty`, if an Object has any of these 
            { $$prop: true, get: function () { ... }, set: function () { ... } } 
        */

        if (_is.def(_val) && _is.obj(_val) && (_val.$$prop || _is.fn(_val.get) || _is.fn(_val.set)) && !_val._class) {
          Object.defineProperty(_prototype ? _obj.prototype : _obj, i, _val);
        }
      }, this);
    }, _obj);
    return _obj;
  };
}; // Set class prototype properties and methods

let _method = _attachProp("prototype"); // Set static properties and methods

let _static = _attachProp("static"); // Create a copy of static methods that can function as prototype methods

let _alias = function (props = {}, opts) {
  let thisArg = opts && opts.thisArg || []; // This as first argument

  let _keys = getOwnPropertyNames(props);

  let chain = opts && opts.chain || [];

  let result = {},
      _args;

  for (let idx = 0; idx < _keys.length; idx++) {
    let i = _keys[idx],
        val = props[i],
        toStr;

    if (_is.fn(val)) {
      // For more info: stackoverflow.com/questions/19696015
      result[i] = function (...args) {
        if (_is.fn(opts)) {
          return opts.call(this, val, ...args);
        } else {
          _args = thisArg.includes(i) ? [this, ...args] : args;

          if (chain.includes(i)) {
            val.apply(this, _args);
            return this;
          }

          return val.apply(this, _args);
        }
      };

      toStr = val.toString.bind(val);
      result[i].toString = chain.includes(i) ? () => `${toStr()} return this;` : toStr;
      result[i].valueOf = val.valueOf.bind(val);
    }
  }

  return result;
}; // Easy access to configurable property attributes, like get, set, writeable, value etc...

let _configAttr = function (attr = "get", type = "function") {
  return val => {
    let _val = val;

    if (type == "function") {
      _val = Function(`with (this) return ${val}`);
      _val.toString = val.toString;
    }

    return {
      [attr]: _val
    };
  };
}; // Get and set property attributes

let _get = _configAttr("get", "function");
let _set = _configAttr("set", "function"); // Call the parent version of a method

let _callsuper = function (obj, method, ...args) {
  let _prototype = obj.prototype; // Only static methods have access to the prototype Object

  let _parent = null,
      $ = obj,
      _const = $,
      _super = _const.SuperClass; // Climb prototype chain to find method not equal to callee's method

  while (_super) {
    _super = _prototype ? _super : _super.prototype;

    if ($[method] != _super[method]) {
      _parent = _super[method];
      break;
    }

    $ = _super;
    _const = $.constructor;
    _super = _const.SuperClass;
  }

  if (!_parent) {
    console.error(`${method} method not found in prototype chain.`);
    return;
  }

  return args.length > 0 ? _parent.apply(obj, args) : _parent.call(obj);
}; // All properties combined

let _props = {
  is: _is,
  fnval: _fnval,
  argNames: _argNames,
  method: _method,
  static: _static,
  path: _path,
  attr: _attr,
  alias: _alias,
  configAttr: _configAttr,
  get: _get,
  set: _set,
  new: _new,
  callsuper: _callsuper
};
let props = {
  _is,
  _fnval,
  _argNames,
  _method,
  _static,
  _path,
  _attr,
  _alias,
  _configAttr,
  _get,
  _set,
  _new,
  _callsuper,
  ..._props
}; // Properties methods with Class support

let aliasMethods = _alias(props, {
  thisArg: ["_new", "_attr", "_path", "_method", "_static", "_callsuper"]
}); // Create classes

let _class = function (...args) {
  let Class, SubClass, Parent; // SubClass constructor

  SubClass = function () {}; // Set parent constructor


  if (_is.fn(args[0]) || _is.arr(args[0].SubClasses)) {
    if (_is.arr(Class.SubClasses)) {
      Parent = Class;
    } else {
      Parent = args.shift();
    }
  } // Class Object


  Class = function (..._args) {
    // Current Class
    if (_is.not("inst", this, Class)) {
      return _new(Class, _args);
    }

    this._args = _args; // Arguments
    // Initialize Class

    return this.init.apply(this, this._args);
  }; // Extend parent class, if any


  if (Parent) {
    Parent.prototype.constructor = Parent;
    SubClass.prototype = Parent.prototype;
    Class.prototype = new SubClass();
    void (Parent.SubClasses && Parent.SubClasses.push(Class));
  }

  Class.SuperClass = Parent; // Current Class's Parent if any

  Class.SubClasses = []; // List of SubClasses
  // Extend Class

  assign(Class, aliasMethods);
  assign(Class.prototype, aliasMethods, {
    SuperClass: Class.SuperClass,
    SubClasses: Class.SubClasses
  }); // Add Methods to Class

  _method(Class, ...args); // Set Current class type


  if (!Class.prototype._class) {
    Class.prototype._class = "New Class";
  } // Set Class constructor


  Class.prototype.constructor = Class;

  if (!Class.prototype.init) {
    Class.prototype.init = function () {};
  } else {
    // Set toString & toValue
    Class.toString = Class.prototype.init.toString;
    Class.toValue = Class.prototype.init.toValue;
  }

  return Class;
};
assign(_class, aliasMethods); // Extend _class

const {
  _get: _get$1,
  _is: _is$1,
  _argNames: _argNames$1,
  keys: keys$1
} = _class;
const {
  readyState
} = document; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

let passive = false,
    opts = {},
    noop = () => {};

opts = Object.defineProperty({}, "passive", {
  get: () => passive = {
    capture: false,
    passive: true
  }
});
window.addEventListener("PassiveEventTest", noop, opts);
window.removeEventListener("PassiveEventsTest", noop, opts); // Event class

let _event = _class({
  _class: "Event",
  // Class name
  _events: {},
  // Event info.
  _emit: [],
  // Store events set to be emitted
  // Name of all event's
  _names: _get$1("Object.keys(_events)"),
  // Number of events
  _eventCount: _get$1("_names.length"),

  // Prepare the event
  _preEvent(evt) {
    if (!this._events[evt]) // List of event's
      {
        this._events[evt] = [];
      }

    return this._events[evt];
  },

  // Apply event as object
  _eventApp(callback, scope, event) {
    return {
      callback: callback,
      scope: scope || this,
      event: event
    };
  },

  // Add a listener for a given event
  on(evt, callback, scope) {
    let $EvtApp, $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    keys$1(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("arr", evt)) {
        $EvtApp = this._eventApp($evt, callback || this, key);

        this._preEvent(key).push($EvtApp); // Set event list

      } else {
        $EvtApp = this._eventApp(callback, scope, $evt);

        this._preEvent($evt).push($EvtApp); // Set event list

      }
    }, this);
    return this;
  },

  // Call all function(s) within an event
  emit(evt, ...args) {
    let $Evt,
        $args = args;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    evt.forEach(function ($evt) {
      $Evt = this._preEvent($evt);

      if (!this._emit.includes($evt)) {
        this._emit.push($evt);
      }

      $Evt.forEach(_evt => {
        $args = args;

        if (_argNames$1(_evt.callback)[0] == "$evt") {
          $args = [_evt, ...args];
        }

        _evt.callback.apply(_evt.scope, $args);
      }, this);
    }, this);
    return this;
  },

  // Removes a listener for a given event
  off(evt, callback, scope) {
    let $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let _off = function ($evt, callback, scope) {
      let _Evt = this._preEvent($evt);

      if (callback) {
        let i,
            app = this._eventApp(callback, scope || this, $evt);

        _Evt.forEach((val, _i) => {
          if (stringify_3(val) == stringify_3(app)) {
            i = _i;
          }
        }, this);

        if (i > -1) {
          _Evt.splice(i, 1);
        }
      } else {
        delete this._events[$evt];
      }
    }.bind(this);

    keys$1(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("obj", evt)) {
        _off(key, $evt, scope);
      } else {
        _off($evt, callback, scope);
      }
    }, this);
    return this;
  },

  // Adds a one time event listener for a given event
  once(evt, callback, scope) {
    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let $Fn = function (...args) {
      this.off(evt, $Fn, scope);
      callback.apply(scope, args);
    };

    this.on(evt, $Fn, scope);
    return this;
  },

  // List's all listeners for a given event
  listeners(evt) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback);
  },

  // List's all listener values for a given event
  listenerValues(evt, ...args) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback.call(val.scope, ...args));
  },

  // Clear all events
  clear() {
    this._eventCount = 0;
    this._events = {};
    return this;
  },

  // Clear all events
  clearListeners(evt) {
    this._events[evt] = [];
    return this;
  },

  // Alias for the `on` method
  add: _get$1("on"),
  bind: _get$1("on"),
  // Alias for the `off` method
  remove: _get$1("off"),
  unbind: _get$1("off"),
  // Alias for the `emit` method
  fire: _get$1("emit"),
  trigger: _get$1("emit"),
  // Alias for the `listeners` method
  callbacks: _get$1("listeners")
}).static({
  nativeEvents: `ready load blur focus focusin focusout resize click scroll dblclick 
    mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave 
    change select submit keydown keypress keyup contextmenu`.split(" "),

  applyNative(evt, el, ev) {
    let _emit = e => {
      evt.emit("ready load", e);
    };

    if (/ready|load/.test(ev)) {
      if (!/in/.test(readyState)) {
        _emit();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', _emit);
      } else {
        document.attachEvent('onreadystatechange', () => {
          if (!/in/.test(readyState)) _emit();
        });
      }
    } else {
      el.addEventListener(ev, e => {
        evt.emit(ev, e);
      }, ev == "scroll" ? passive : {});
    }
  }

});

const {
  createElement,
  documentElement
} = document;
const {
  _get: _get$2,
  _alias: _alias$1
} = _class;
let Ele;
let tagRE = /^\s*<(\w+|!)[^>]*>/;
let {
  applyNative,
  nativeEvents
} = _event;
let _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"];

let _qsa = (dom = document, sel) => _is.str(sel) && sel.length ? [...dom.querySelectorAll(sel)] : []; // The matches() method checks to see if the Element would be selected by the provided selectorString -- in other words -- checks if the element "is" the selector.


let _matches = (ele, sel) => {
  let matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
  if (matchSel) return matchSel.call(ele, sel);
}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.


let _contains = (parent, node) => {
  if (parent.contains) return parent != node && parent.contains(node);

  while (node && (node = node.parentNode)) if (node == parent) return true;

  return false;
}; // Allow default Array methods to work as Element Object methods


let arrProto = _alias$1(Array.prototype); // Create an Element List from a HTML string


let _createElem = html => {
  let dom, container;
  container = createElement('div');
  container.innerHTML = '' + html;
  dom = [].slice.call(container.childNodes);
  dom.forEach(el => {
    container.removeChild(el);
  });
  return dom;
}; // Element selector


let _elem = sel => {
  if (_is.str(sel)) {
    sel = sel.trim();

    if (tagRE.test(sel)) {
      return _createElem(sel);
    } else {
      return _qsa(document, sel);
    }
  } else if (_is.inst(sel, Ele)) {
    return sel.ele;
  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
    return [...sel].filter(item => _is.def(item));
  } else if (_is.obj(sel) || _is.el(sel)) {
    return [sel];
  } else if (_is.fn(sel)) {
    Ele(document).ready(sel);
  }

  return [];
}; // Traverse DOM Depth First


let traverseDF = (_node, fn, childType = "childNodes") => {
  let recurse; // This is a recurse and immediately-invoking function

  recurse = node => {
    // Step 2
    node[childType] && node[childType].forEach(recurse, node); // Step 3

    fn.call(node, node); // Step 4
  };

  recurse(_node); // Step 1
}; // Quickly filter nodes by a selector 


let _filter = (nodes, sel) => !_is.def(sel) ? Ele(nodes) : Ele(nodes).filter(sel); // Select all the different values in an Array, based on underscorejs


let _uniq = arr => {
  return [].filter.call(arr, (val, idx) => arr.indexOf(val) == idx);
}; // Quickly set the value of an attribute or remove the attribute completely from a node


let _setAttr = (node, name, value) => value == null ? node.removeAttribute(name) : node.setAttribute(name, value); // Select all children of an element


let _children = el => {
  return 'children' in el ? [].slice.call(el.children) : [].map.call(el.childNodes, node => {
    if (node.nodeType == 1) return node;
  });
}; // Transform  string value to the proper type of value eg. "12" = 12, "[12, 'xyz']" = [12, 'xyz']


let _valfix = value => {
  let validTypes = /^true|false|null|undefined|\d+$/;

  let _fn = v => Function(`"use strict"; return ${v};`)();

  let objectType = /^[[{]([\s\S]+)?[\]}]$/;

  try {
    return validTypes.test(value) ? _fn(value) : objectType.test(value) ? JSON.parse(value.replace(/'/g, "\"")) : value;
  } catch (e) {
    return value;
  }
}; // Decide if the value deserves px at the 


let _maybeAddPx = (name, val) => {
  return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;
}; // Element Object [Based on Zepto.js]


Ele = _class(_event, arrProto, {
  init(sel = '') {
    this.sel = sel; // Selector

    this.ele = _elem(this.sel); // Element

    for (let i = 0; i < this.length; i++) this[i] = this.ele[i];
    /*this.timeline = anime.timeline({
        targets: this,
        autoplay: false
    });*/

  },

  on($super, evt, callback, scope) {
    let _same;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    _same = _intersect(evt, nativeEvents);
    return this.forEach(function (el) {
      if (_same.length > 0) {
        _same.forEach(function (ev) {
          applyNative(this, el, ev);
        }, this);
      }

      $super(evt, callback, scope || el);
    }, this);
  },

  length: _get$2("len"),
  len: _get$2("ele.length"),

  each(fn) {
    [].every.call(this, function (el, idx) {
      return fn.call(el, el, idx) != false;
    });
    return this;
  },

  get(idx) {
    return _is.undef(idx) ? this.slice() : this[idx >= 0 ? idx : idx + this.length];
  },

  nth: _get$2("get"),

  size() {
    return this.length;
  },

  toArray() {
    return this.get();
  },

  remove() {
    return this.each(el => {
      if (_is.def(el.parentNode)) ;
      el.parentNode.removeChild(el);
    });
  },

  not(sel) {
    let excludes,
        $this = this;
    return Ele(this.reduce(function (acc, el, idx) {
      if (_is.fn(sel) && _is.def(sel.call)) {
        if (!sel.call(el, el, idx)) acc.push(el);
      } else {
        excludes = _is.str(sel) ? $this.filter(sel) : _is.arrlike(sel) && _is.fn(sel.item) ? [].slice.call(sel) : Ele(sel);
        if (excludes.indexOf(el) < 0) acc.push(el);
      }

      return acc;
    }, [], this));
  },

  filter(sel) {
    if (_is.fn(sel)) return this.not(this.not(sel));
    return [].filter.call(this, ele => _matches(ele, sel), this);
  },

  has(sel) {
    return this.filter(el => {
      return _is.obj(sel) ? _contains(el, sel) : Ele(el).find(sel).size();
    });
  },

  eq(idx) {
    return idx == -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
  },

  first() {
    let el = this.get(0);
    return el && !_is.obj(el) ? el : Ele(el);
  },

  last() {
    let el = this.get(-1);
    return el && !_is.obj(el) ? el : Ele(el);
  },

  find(sel) {
    let result,
        $this = this;
    if (!sel) result = Ele();else if (_is.obj(sel)) {
      result = Ele(sel).filter(el => {
        return [].some.call($this, parent => _contains(parent, el));
      });
    } else if (this.length == 1) {
      result = Ele(_qsa(this.get(0), sel));
    } else {
      result = this.map(el => _qsa(el, sel));
    }
    return result;
  },

  closest(sel, ctxt) {
    let list = _is.obj(sel) && Ele(sel);
    return Ele(this.reduce((acc, ele) => {
      do {
        if (list ? list.indexOf(ele) >= 0 : _matches(ele, sel)) break;
        ele = ele != ctxt && _is.not("doc", ele) && ele.parentNode;
      } while (ele !== null && ele.nodeType === 1);

      if (ele && acc.indexOf(ele) < 0) acc.push(ele);
      return acc;
    }, []));
  },

  parents(sel) {
    let ancestors = [],
        nodes = this;

    while (nodes.length > 0) {
      nodes = nodes.map(el => {
        if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {
          ancestors.push(el);
          return el;
        }
      });
    }

    return _filter(ancestors, sel);
  },

  // `pluck` based on underscore.js, but way more powerful
  pluck(prop) {
    return this.map(el => _path(el, prop));
  },

  parent(sel) {
    return _filter(_uniq(this.pluck('parentNode')), sel);
  },

  children(sel) {
    return _filter(this.map(el => _children(el)), sel);
  },

  contents() {
    return this.map(el => el.contentDocument || [].slice.call(el.childNodes));
  },

  siblings(sel) {
    return _filter(this.map(el => [].filter.call(_children(el.parentNode), child => child != el)), sel);
  },

  replaceWith: content => undefined.before(content).remove(),
  clone: () => undefined.map(el => el.cloneNode(true)),

  toggle(opt) {
    return this.each(el => {
      let _el = Ele(el);

      let _opt = opt || el.style("display") == "none";

      _el[_opt ? "show" : "hide"]();
    });
  },

  prev: sel => Ele(undefined.pluck('previousElementSibling')).filter(sel || '*'),
  next: sel => Ele(undefined.pluck('nextElementSibling')).filter(sel || '*'),

  html(...args) {
    let [html] = args;
    return args.length ? this.each((el, idx) => {
      let originHTML = el.innerHTML;
      Ele(el).empty().append(_fnval(html, [idx, originHTML], el));
    }) : this.length ? this.get(0).innerHTML : null;
  },

  text(...args) {
    let [text] = args;
    return args.length ? this.each((el, idx) => {
      let newText = _fnval(text, [idx, el.textContent], el);

      el.textContent = _is.nul(newText) ? '' : `${newText}`;
    }) : this.length ? this.pluck('textContent').join("") : null;
  },

  attr(name, val) {
    let result;

    if (_is.str(name) && _is.undef(val)) {
      result = this.length && this.get(0).nodeType == 1 && this.get(0).getAttribute(name);
      return !_is.nul(result) ? result : undefined;
    } else {
      return this.each((el, idx) => {
        if (el.nodeType != 1) return;

        if (_is.arr(name)) {
          for (let i in name) _setAttr(el, i, name[i]);
        } else {
          _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));
        }
      });
    }
  },

  removeAttr(name) {
    return this.each(el => {
      el.nodeType == 1 && name.split(' ').forEach(attr => {
        _setAttr(el, attr);
      });
    });
  },

  data(name, value) {
    let attrName = `data-${name}`.toLowerCase();
    let data = _is.def(value) ? this.attr(attrName, value) : this.attr(attrName);
    return data != null ? _valfix(data) : undefined;
  },

  val(...args) {
    let [value] = args,
        _el;

    if (args.length) {
      if (_is.nul(value)) value = "";
      return this.each((el, idx) => {
        el.value = _fnval(value, [idx, el.value], el);
      });
    } else {
      _el = this.get(0);
      return _el && (_el.multiple ? Ele(_el).find('option').filter(el => el.selected).pluck('value') : _el.value);
    }
  },

  offset(coords) {
    let obj;

    if (coords) {
      return this.each((el, idx) => {
        let $this = Ele(el);

        let _coords = _fnval(coords, [idx, $this.offset()], el);

        let parentOffset = $this.offsetParent().offset();
        let props = {
          top: _coords.top - parentOffset.top,
          left: _coords.left - parentOffset.left
        };
        if ($this.style('position') == 'static') props.position = 'relative';
        $this.style(props);
      });
    }

    if (!this.length) return null;
    if (documentElement != this.get(0) && !_contains(documentElement, this.get(0))) return {
      top: 0,
      left: 0
    };
    obj = this.get(0).getBoundingClientRect();
    return {
      left: obj.left + window.pageXOffset,
      top: obj.top + window.pageYOffset,
      width: Math.round(obj.width),
      height: Math.round(obj.height)
    };
  },

  style(...args) {
    let [prop, val] = args,
        css = '',
        key;

    if (args.length < 2) {
      let el = this.get(0);
      if (!el) return;

      if (_is.str(prop)) {
        return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
      } else if (_is.arr(prop)) {
        let props = {};
        let computedStyle = window.getComputedStyle(el, '');
        prop.forEach(_prop => {
          props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
        });
        return props;
      }
    }

    if (_is.str(prop)) {
      if (!val && val != 0) {
        this.each(el => {
          el.style.removeProperty(prop);
        });
      } else {
        css = prop + ":" + _maybeAddPx(prop, val);
      }
    } else {
      for (key in prop) {
        if (!prop[key] && prop[key] != 0) {
          this.each(el => {
            el.style.removeProperty(key);
          });
        } else {
          css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
        }
      }
    }

    return this.each(el => {
      el.style.cssText += ';' + css;
    });
  },

  show: () => undefined.style("display", ""),
  hide: () => undefined.style("display", "none"),
  empty: () => undefined.each(el => {
    el.innerHTML = '';
  }),

  index(el) {
    return el ? this.indexOf(Ele(el).get(0)) : this.parent().children().indexOf(this.get(0));
  }

}, // Generate shortforms for events eg. .click(), .hover(), etc... 
nativeEvents.reduce((acc, name) => {
  // Handle event binding
  acc[name] = function (...args) {
    return this.on(name, ...args);
  };

  return acc;
}, {
  hover(fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }

}), // Generate the `width` and `height` methods
['width', 'height'].reduce((acc, sz) => {
  let prop = _capital(sz);

  acc[sz] = function (value) {
    let offset,
        el = this.get(0);

    if (_is.undef(value)) {
      if (_is.win(el)) {
        return el[`inner${prop}`];
      } else if (_is.doc(el)) {
        return el.documentElement[`scroll${prop}`];
      } else {
        return (offset = this.offset()) && offset[sz];
      }
    } else {
      return this.each((_el, idx) => {
        el = Ele(_el);
        el.style(sz, _fnval(value, [idx, el[sz]()], _el));
      });
    }
  };

  return acc;
}, {}), // Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
['after', 'prepend', 'before', 'append'].reduce(function (acc, fn, idx) {
  let inside = idx % 2; //=> prepend, append

  acc[fn] = function (...args) {
    // Arguments can be nodes, arrays of nodes, Element objects and HTML strings
    let clone = this.length > 1;
    let nodes = args.map(function (arg) {
      if (_is.arr(arg)) {
        return arg.reduce((acc, el) => {
          if (_is.def(el.nodeType)) acc.push(el);else if (_is.inst(el, Ele)) acc = acc.concat(el.get());else if (_is.str(el)) acc = acc.concat(_createElem(el));
          return acc;
        }, []);
      }

      return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);
    }).filter(item => _is.def(item));
    return this.each(function (target) {
      let parent = inside ? target : target.parentNode;

      let parentInDoc = _contains(documentElement, parent);

      let next = target.nextSibling,
          first = target.firstChild; // Convert all methods to a "before" operation

      target = [next, first, target, null][idx];
      nodes.forEach(function (node) {
        if (clone) node = node.cloneNode(true);else if (!parent) return Ele(node).remove();
        parent.insertBefore(node, target);

        if (parentInDoc) {
          traverseDF(node, function (el) {
            if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() == 'SCRIPT' && (!el.type || el.type == 'text/javascript') && !el.src) {
              let target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target.eval.call(target, el.innerHTML);
            }
          });
        }
      });
    });
  }; // after    => insertAfter, prepend  => prependTo
  // before   => insertBefore, append   => appendTo


  acc[inside ? `${fn}To` : `insert${_capital(fn)}`] = function (html) {
    Ele(html)[fn](this);
    return this;
  };

  return acc;
}, {}));
var el = Ele;

// import swup from "swup";
// import _event from "./components/event";
// import scrollPlugin from "@swup/scroll-plugin";
// import slideTheme from '@swup/slide-theme';
// import preload from '@swup/preload-plugin';
// import anime from "anime";
// _event, 

let _log = (...args) => args.forEach(v => console.log(v));

let ele = el("<a>Hello</a>");
ele.appendTo("body");

_log({
  message: "Hello"
});
/*
new swup({
	requestHeaders: {
		"X-Requested-With": "swup", // So we can tell request comes from swup
		"x-partial": "swup" // Request a partial html page
	}
});*/

//# sourceMappingURL=../maps/app.modern.min.js.map
