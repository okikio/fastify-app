/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.';
}
/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */


function getCutoff(array, value) {
  var length = array.length;

  for (var index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */


function createReplacer(replacer, circularReplacer) {
  var hasReplacer = typeof replacer === 'function';
  var hasCircularReplacer = typeof circularReplacer === 'function';
  var cache = [];
  var keys = [];
  return function replace(key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoff(cache, this);

        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys[keys.length] = key;
        var valueCutoff = getCutoff(cache, value);

        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=" + getReferenceKey(keys, valueCutoff) + "]";
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 *
 * @param the value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */


function stringify(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
}

let _stringify = obj => {
  let fns = [];
  let json = stringify(obj, (key, val) => {
    if (typeof val == "function") {
      fns.push(val.toString());
      return "_";
    }

    return val;
  }, 4);
  return json.replace(/"_"/g, () => fns.shift());
};

var stringify_1 = {
  stringify,
  _stringify
};
var stringify_3 = stringify_1._stringify;

let {
  assign,
  keys,
  values
} = Object;
let {
  isArray,
  from,
  of
} = Array; // Create an array of values that two array share in common

let _is = (val, type) => typeof val == type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len == 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: val => !_is(val, "undefined"),
  win: val => val && val.window,
  undef: _type("undefined"),
  bool: _type("boolean"),
  fn: _type("function"),
  obj: _type("object"),
  str: _type("string"),
  nul: _type("null"),
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (_is.not("fn", fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
}; // Argument names

let _argNames = fn => {
  let args = fn.toString().match(/^[\s(]*function[^(]*\(([^)]*)\)/)[1].replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',');
  return args.length == 1 && !args[0] ? [] : args;
}; // Get or set a value in an Object, based on it's path

let _path = (obj, path, val) => {
  path = path.toString().split(/[.,]/g);

  if (_is.def(val)) {
    if (path.length > 1) {
      _path(obj[path.shift()], path, val);
    } else {
      obj[path[0]] = val;
    }

    return val;
  } else {
    path.forEach(_val => {
      obj = obj[_val];
    });
  }

  return obj;
};
/* 
    Builds on path and adds more power, 
    * Allows for multiple paths one value
    * Using Objects as paths and setting the values individually
    * Access values as an Array, from multiple paths
*/

let _attr = (obj, path, val) => {
  if (_is.obj(path) && _is.not("arr", path)) {
    return assign(obj, path);
  } else if (_is.arr(path)) {
    if (_is.undef(val)) {
      return path.map(_key => _path(obj, _key));
    } else {
      path.forEach(_key => {
        _path(obj, _key, val);
      });
    }
  } else {
    return _path(obj, path, val);
  }

  return obj;
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

let _new = function (ctor, args) {
  let F = function () {
    return ctor.apply(this, args);
  };

  F.prototype = ctor.prototype;
  return new F();
};

let _attachProp = where => {
  let _prototype = where == "prototype";

  return (_obj, ...args) => {
    // If super class exists, set value of parent to `SuperClass` prototype
    let parent = _prototype && _obj.SuperClass ? _obj.SuperClass.prototype : _obj.SuperClass;
    args.forEach(val => {
      // Transform functions to Objects
      let obj = _fnval(val, [_obj, _obj.constructor], _prototype ? _obj.prototype : _obj); // Iterate through Object


      keys(obj).forEach(i => {
        let _val = obj[i],
            preVal = _val; // If a Parent Class is Present, Set any argument/params named `$super` to the `Parent`

        if (_is.fn(_val)) {
          if (parent && _argNames(_val)[0] == "$super") {
            // Let the first argument be the original value
            _val = (...args) => {
              let parentFn = parent[i].bind(_obj);
              return preVal.apply(_obj, [parentFn, ...args]);
            };
          }

          _val = _val.bind(_obj); // For debugging purposes

          _val.valueOf = preVal.valueOf.bind(preVal);
          _val.toString = preVal.toString.bind(preVal);
        }

        (_prototype ? _obj.prototype : _obj)[i] = _val; // Redefinition Error Fix

        /* 
            Allows the use of `Object.defineProperty`, if an Object has any of these 
            { $$prop: true, get: function () { ... }, set: function () { ... } } 
        */

        if (_is.def(_val) && _is.obj(_val) && _is.not("nul", _val) && (_val.$$prop || _val.get && _is.fn(_val.get) || _val.set && _is.fn(_val.set)) && !_val._class) {
          Object.defineProperty(_prototype ? _obj.prototype : _obj, i, _val);
        }
      }, _obj);
    }, _obj);
    return _obj;
  };
}; // Set class prototype properties and methods

let _method = _attachProp("prototype"); // Set static properties and methods

let _static = _attachProp("static"); // Create a copy of static methods that can function as prototype methods

let _alias = function (props = {}, opts) {
  let thisArg = opts && opts.thisArg || []; // This as first argument

  let chain = opts && opts.chain || [],
      toStr;

  let result = {},
      val,
      _args,
      _key;

  let _keys = keys(props);

  for (let i = 0; i < _keys.length; i++) {
    val = props[_key = _keys[i]];

    if (_is.fn(val)) {
      result[_key] = function (...args) {
        if (_is.fn(opts)) {
          return opts.call(this, val, ...args);
        } else {
          _args = thisArg.includes(i) ? [this, ...args] : args;

          if (chain.includes(i)) {
            val.apply(this, _args);
            return this;
          }

          return val.apply(this, _args);
        }
      };

      toStr = val.toString.bind(val);
      result[_key].toString = chain.includes(i) ? () => `${toStr()} return this;` : toStr;
      result[_key].valueOf = val.valueOf.bind(val);
    }
  }

  return result;
}; // Easy access to configurable property attributes, like get, set, writeable, value etc...

let _configAttr = function (attr = "get", type = "function") {
  return val => {
    let _val = val;

    if (type == "function") {
      _val = Function(`with (this) return ${val}`);
      _val.toString = val.toString;
    }

    return {
      [attr]: _val
    };
  };
}; // Get and set property attributes

let _get = _configAttr("get", "function");
let _set = _configAttr("set", "function"); // Call the parent version of a method

let _callsuper = function (obj, method, ...args) {
  let _prototype = obj.prototype; // Only static methods have access to the prototype Object

  let _parent = null,
      $ = obj,
      _const = $,
      _super = _const.SuperClass; // Climb prototype chain to find method not equal to callee's method

  while (_super) {
    _super = _prototype ? _super : _super.prototype;

    if ($[method] != _super[method]) {
      _parent = _super[method];
      break;
    }

    $ = _super;
    _const = $.constructor;
    _super = _const.SuperClass;
  }

  if (!_parent) {
    console.error(`${method} method not found in prototype chain.`);
    return;
  }

  return args.length > 0 ? _parent.apply(obj, args) : _parent.call(obj);
}; // All properties combined

let props = {
  _is,
  _fnval,
  _argNames,
  _method,
  _static,
  _path,
  _attr,
  _alias,
  _configAttr,
  _get,
  _set,
  _new,
  _callsuper
}; // Properties methods with Class support

let aliasMethods = _alias(props, {
  thisArg: ["_attr", "_path", "_method", "_static"] // "_new", , "_callsuper"

}); // Create classes

let _class = function (...args) {
  let Class, SubClass, Parent; // SubClass constructor

  SubClass = function () {}; // Set parent constructor


  if (_is.fn(args[0]) || _is.arr(this.SubClasses)) {
    if (_is.arr(this.SubClasses)) {
      Parent = this;
    } else {
      Parent = args.shift();
    }
  } // Class Object


  Class = function (..._args) {
    // Current Class
    if (_is.not("inst", this, Class)) {
      return _new(Class, _args);
    }

    this._args = _args; // Arguments
    // Initialize Class

    return this.init.apply(this, this._args);
  }; // Extend parent class, if any


  if (Parent) {
    Parent.prototype.constructor = Parent;
    SubClass.prototype = Parent.prototype;
    Class.prototype = new SubClass();
    void (Parent.SubClasses && Parent.SubClasses.push(Class));
  }

  Class.SuperClass = Parent; // Current Class's Parent if any

  Class.SubClasses = []; // List of SubClasses
  // Extend Class

  assign(Class.prototype, aliasMethods, {
    SuperClass: Class.SuperClass,
    SubClasses: Class.SubClasses
  });
  assign(Class.prototype, {
    // callsuper: Class.prototype._callsuper,
    method: Class.prototype._method,
    static: Class.prototype._static,
    attr: Class.prototype._attr
  }); // Add Methods to Class

  _method(Class, ...args); // Set Current class type


  if (!Class.prototype._class) {
    Class.prototype._class = "New Class";
  } // Set Class constructor


  Class.prototype.constructor = Class;

  if (!Class.prototype.init) {
    Class.prototype.init = function () {};
  } else {
    // Set toString & toValue
    Class.toString = Class.prototype.init.toString;
    Class.toValue = Class.prototype.init.toValue;
  }

  return Class(...args);
};
assign(_class, props); // Extend _class

const {
  _get: _get$1,
  _is: _is$1,
  _argNames: _argNames$1,
  keys: keys$1
} = _class;

let passive = false,
    opts = {},
    noop = () => {};

opts = Object.defineProperty({}, "passive", {
  get: () => passive = {
    capture: false,
    passive: true
  }
});
window.addEventListener("PassiveEventTest", noop, opts);
window.removeEventListener("PassiveEventsTest", noop, opts); // Event class

let _event = _class({
  _class: "Event",
  // Class name
  _events: {},
  // Event info.
  _emit: [],
  // Store events set to be emitted
  // Name of all event's
  _names: _get$1("Object.keys(_events)"),
  // Number of events
  _eventCount: _get$1("_names.length"),

  // Prepare the event
  _preEvent(evt) {
    if (!this._events[evt]) // List of event's
      {
        this._events[evt] = [];
      }

    return this._events[evt];
  },

  // Apply event as object
  _eventApp(callback, scope, event) {
    return {
      callback: callback,
      scope: scope || this,
      event: event
    };
  },

  // Add a listener for a given event
  on(evt, callback, scope) {
    let $EvtApp, $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    keys$1(evt).forEach(key => {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("arr", evt)) {
        $EvtApp = this._eventApp($evt, callback || this, key);

        this._preEvent(key).push($EvtApp); // Set event list

      } else {
        $EvtApp = this._eventApp(callback, scope, $evt);

        this._preEvent($evt).push($EvtApp); // Set event list

      }
    }, this);
    return this;
  },

  // Call all function(s) within an event
  emit(evt, ...args) {
    let $Evt,
        $args = args;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    evt.forEach($evt => {
      $Evt = this._preEvent($evt);

      if (!this._emit.includes($evt)) {
        this._emit.push($evt);
      }

      $Evt.forEach(_evt => {
        $args = args;

        if (_argNames$1(_evt.callback)[0] == "$evt") {
          $args = [_evt, ...args];
        }

        _evt.callback.apply(_evt.scope, $args);
      }, this);
    }, this);
    return this;
  },

  // Removes a listener for a given event
  off(evt, callback, scope) {
    let $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let _off = (($evt, callback, scope) => {
      let _Evt = this._preEvent($evt);

      if (callback) {
        let i,
            app = this._eventApp(callback, scope || this, $evt);

        _Evt.forEach((val, _i) => {
          if (stringify_3(val) == stringify_3(app)) {
            i = _i;
          }
        }, this);

        if (i > -1) {
          _Evt.splice(i, 1);
        }
      } else {
        delete this._events[$evt];
      }
    }).bind(this);

    keys$1(evt).forEach(key => {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("obj", evt)) {
        _off(key, $evt, scope);
      } else {
        _off($evt, callback, scope);
      }
    }, this);
    return this;
  },

  // Adds a one time event listener for a given event
  once(evt, callback, scope) {
    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let $Fn = function (...args) {
      this.off(evt, $Fn, scope);
      callback.apply(scope, args);
    };

    this.on(evt, $Fn, scope);
    return this;
  },

  // List's all listeners for a given event
  listeners(evt) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback);
  },

  // List's all listener values for a given event
  listenerValues(evt, ...args) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback.call(val.scope, ...args));
  },

  // Clear all events
  clear() {
    this._eventCount = 0;
    this._events = {};
    return this;
  },

  // Clear all events
  clearListeners(evt) {
    this._events[evt] = [];
    return this;
  },

  // Alias for the `on` method
  add: _get$1("on"),
  bind: _get$1("on"),
  // Alias for the `off` method
  remove: _get$1("off"),
  unbind: _get$1("off"),
  // Alias for the `emit` method
  fire: _get$1("emit"),
  trigger: _get$1("emit"),
  // Alias for the `listeners` method
  callbacks: _get$1("listeners")
})
/*
.static({
  nativeEvents: `ready load blur focus focusin focusout resize click scroll dblclick 
  mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave 
  change select submit keydown keypress keyup contextmenu`.split(" "),
  applyNative(evt, el, ev) {
      let _emit = e => { evt.emit("ready load", e); };
        if (/ready|load/.test(ev)) {
          if (!/in/.test(readyState)) { _emit(); }
          else if (document.addEventListener) {
              document.addEventListener('DOMContentLoaded', _emit);
          } else {
              document.attachEvent('onreadystatechange', () => {
                  if (!/in/.test(readyState)) _emit();
              });
          }
      } else {
          el.addEventListener(ev, e => { 
              evt.emit(ev, e); 
          }, ev == "scroll" ? passive : {});
      }
  }
})*/
;

// import swup from "swup";
// import slideTheme from '@swup/slide-theme';
// import preload from '@swup/preload-plugin';
// import anime from "anime";
// let ele = new el("body");

let _log = (...args) => args.forEach(v => console.log(v));

_log(_event._static({})); // 

/*ele.set("style", {});
fetch("/assets/app.js")
	.then(console.log);*/


console.log({
  message: "Hello"
});
/*
new swup({
	requestHeaders: {
		"X-Requested-With": "swup", // So we can tell request comes from swup
		"x-partial": "swup" // Request a partial html page
	}
});*/

//# sourceMappingURL=../maps/app.modern.min.js.map
