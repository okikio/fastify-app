(function (factory) {
	typeof define === 'function' && define.amd ? define('app', factory) :
	factory();
}(function () { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var DOCUMENT_NODE_TYPE = 9;
	/**
	 * A polyfill for Element.matches()
	 */

	if (typeof Element !== 'undefined' && !Element.prototype.matches) {
	  var proto = Element.prototype;
	  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
	}
	/**
	 * Finds the closest parent that matches a selector.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @return {Function}
	 */


	function closest(element, selector) {
	  while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
	    if (typeof element.matches === 'function' && element.matches(selector)) {
	      return element;
	    }

	    element = element.parentNode;
	  }
	}

	var closest_1 = closest;

	/**
	 * Delegates event to a selector.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @param {String} type
	 * @param {Function} callback
	 * @param {Boolean} useCapture
	 * @return {Object}
	 */

	function delegate(element, selector, type, callback, useCapture) {
	  var listenerFn = listener.apply(this, arguments);
	  element.addEventListener(type, listenerFn, useCapture);
	  return {
	    destroy: function destroy() {
	      element.removeEventListener(type, listenerFn, useCapture);
	    }
	  };
	}
	/**
	 * Finds closest match and invokes callback.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @param {String} type
	 * @param {Function} callback
	 * @return {Function}
	 */


	function listener(element, selector, type, callback) {
	  return function (e) {
	    e.delegateTarget = closest_1(e.target, selector);

	    if (e.delegateTarget) {
	      callback.call(element, e);
	    }
	  };
	}

	var delegate_1 = delegate;

	var Cache_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var Cache = exports.Cache = function () {
	    function Cache() {
	      _classCallCheck(this, Cache);

	      this.pages = {};
	      this.last = null;
	    }

	    _createClass(Cache, [{
	      key: 'cacheUrl',
	      value: function cacheUrl(page) {
	        if (page.url in this.pages === false) {
	          this.pages[page.url] = page;
	        }

	        this.last = this.pages[page.url];
	        this.swup.log('Cache (' + Object.keys(this.pages).length + ')', this.pages);
	      }
	    }, {
	      key: 'getPage',
	      value: function getPage(url) {
	        return this.pages[url];
	      }
	    }, {
	      key: 'getCurrentPage',
	      value: function getCurrentPage() {
	        return this.getPage(window.location.pathname + window.location.search);
	      }
	    }, {
	      key: 'exists',
	      value: function exists(url) {
	        return url in this.pages;
	      }
	    }, {
	      key: 'empty',
	      value: function empty() {
	        this.pages = {};
	        this.last = null;
	        this.swup.log('Cache cleared');
	      }
	    }, {
	      key: 'remove',
	      value: function remove(url) {
	        delete this.pages[url];
	      }
	    }]);

	    return Cache;
	  }();

	  exports["default"] = Cache;
	});
	unwrapExports(Cache_1);
	var Cache_2 = Cache_1.Cache;

	var classify_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var classify = function classify(text) {
	    var output = text.toString().toLowerCase().replace(/\s+/g, '-') // Replace spaces with -
	    .replace(/\//g, '-') // Replace / with -
	    .replace(/[^\w\-]+/g, '') // Remove all non-word chars
	    .replace(/\-\-+/g, '-') // Replace multiple - with single -
	    .replace(/^-+/, '') // Trim - from start of text
	    .replace(/-+$/, ''); // Trim - from end of text

	    if (output[0] === '/') output = output.splice(1);
	    if (output === '') output = 'homepage';
	    return output;
	  };

	  exports["default"] = classify;
	});
	unwrapExports(classify_1);

	var createHistoryRecord_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var createHistoryRecord = function createHistoryRecord(url) {
	    window.history.pushState({
	      url: url || window.location.href.split(window.location.hostname)[1],
	      random: Math.random(),
	      source: 'swup'
	    }, document.getElementsByTagName('title')[0].innerText, url || window.location.href.split(window.location.hostname)[1]);
	  };

	  exports["default"] = createHistoryRecord;
	});
	unwrapExports(createHistoryRecord_1);

	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(source, true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(source).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	var utils = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var query = exports.query = function query(selector) {
	    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

	    if (typeof selector !== 'string') {
	      return selector;
	    }

	    return context.querySelector(selector);
	  };

	  var queryAll = exports.queryAll = function queryAll(selector) {
	    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

	    if (typeof selector !== 'string') {
	      return selector;
	    }

	    return Array.prototype.slice.call(context.querySelectorAll(selector));
	  };
	});
	unwrapExports(utils);
	var utils_1 = utils.query;
	var utils_2 = utils.queryAll;

	var getDataFromHtml_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
	    return _typeof(obj);
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
	  };

	  var getDataFromHtml = function getDataFromHtml(html, containers) {
	    var content = html.replace('<body', '<div id="swupBody"').replace('</body>', '</div>');
	    var fakeDom = document.createElement('div');
	    fakeDom.innerHTML = content;
	    var blocks = [];

	    var _loop = function _loop(i) {
	      if (fakeDom.querySelector(containers[i]) == null) {
	        // page in invalid
	        return {
	          v: null
	        };
	      } else {
	        (0, utils.queryAll)(containers[i]).forEach(function (item, index) {
	          (0, utils.queryAll)(containers[i], fakeDom)[index].setAttribute('data-swup', blocks.length); // marks element with data-swup

	          blocks.push((0, utils.queryAll)(containers[i], fakeDom)[index].outerHTML);
	        });
	      }
	    };

	    for (var i = 0; i < containers.length; i++) {
	      var _ret = _loop(i);

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof$1(_ret)) === "object") return _ret.v;
	    }

	    var json = {
	      title: fakeDom.querySelector('title').innerText,
	      pageClass: fakeDom.querySelector('#swupBody').className,
	      originalContent: html,
	      blocks: blocks
	    }; // to prevent memory leaks

	    fakeDom.innerHTML = '';
	    fakeDom = null;
	    return json;
	  };

	  exports["default"] = getDataFromHtml;
	});
	unwrapExports(getDataFromHtml_1);

	var fetch_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  var fetch = function fetch(setOptions) {
	    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var defaults = {
	      url: window.location.pathname + window.location.search,
	      method: 'GET',
	      data: null,
	      headers: {}
	    };

	    var options = _extends({}, defaults, setOptions);

	    var request = new XMLHttpRequest();

	    request.onreadystatechange = function () {
	      if (request.readyState === 4) {
	        if (request.status !== 500) {
	          callback(request);
	        } else {
	          callback(request);
	        }
	      }
	    };

	    request.open(options.method, options.url, true);
	    Object.keys(options.headers).forEach(function (key) {
	      request.setRequestHeader(key, options.headers[key]);
	    });
	    request.send(options.data);
	    return request;
	  };

	  exports["default"] = fetch;
	});
	unwrapExports(fetch_1);

	var transitionEnd_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var transitionEnd = function transitionEnd() {
	    var el = document.createElement('div');
	    var transEndEventNames = {
	      WebkitTransition: 'webkitTransitionEnd',
	      MozTransition: 'transitionend',
	      OTransition: 'oTransitionEnd otransitionend',
	      transition: 'transitionend'
	    };

	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return transEndEventNames[name];
	      }
	    }

	    return false;
	  };

	  exports["default"] = transitionEnd;
	});
	unwrapExports(transitionEnd_1);

	var getCurrentUrl_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var getCurrentUrl = function getCurrentUrl() {
	    return window.location.pathname + window.location.search;
	  };

	  exports["default"] = getCurrentUrl;
	});
	unwrapExports(getCurrentUrl_1);

	var markSwupElements_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var markSwupElements = function markSwupElements(element, containers) {
	    var blocks = 0;

	    var _loop = function _loop(i) {
	      if (element.querySelector(containers[i]) == null) {
	        console.warn('Element ' + containers[i] + ' is not in current page.');
	      } else {
	        (0, utils.queryAll)(containers[i]).forEach(function (item, index) {
	          (0, utils.queryAll)(containers[i], element)[index].setAttribute('data-swup', blocks);
	          blocks++;
	        });
	      }
	    };

	    for (var i = 0; i < containers.length; i++) {
	      _loop(i);
	    }
	  };

	  exports["default"] = markSwupElements;
	});
	unwrapExports(markSwupElements_1);

	var Link_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var Link = function () {
	    function Link(elementOrUrl) {
	      _classCallCheck(this, Link);

	      if (elementOrUrl instanceof Element || elementOrUrl instanceof SVGElement) {
	        this.link = elementOrUrl;
	      } else {
	        this.link = document.createElement('a');
	        this.link.href = elementOrUrl;
	      }
	    }

	    _createClass(Link, [{
	      key: 'getPath',
	      value: function getPath() {
	        var path = this.link.pathname;

	        if (path[0] !== '/') {
	          path = '/' + path;
	        }

	        return path;
	      }
	    }, {
	      key: 'getAddress',
	      value: function getAddress() {
	        var path = this.link.pathname + this.link.search;

	        if (this.link.getAttribute('xlink:href')) {
	          path = this.link.getAttribute('xlink:href');
	        }

	        if (path[0] !== '/') {
	          path = '/' + path;
	        }

	        return path;
	      }
	    }, {
	      key: 'getHash',
	      value: function getHash() {
	        return this.link.hash;
	      }
	    }]);

	    return Link;
	  }();

	  exports["default"] = Link;
	});
	unwrapExports(Link_1);

	var helpers = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.Link = exports.markSwupElements = exports.getCurrentUrl = exports.transitionEnd = exports.fetch = exports.getDataFromHtml = exports.createHistoryRecord = exports.classify = undefined;

	  var _classify2 = _interopRequireDefault(classify_1);

	  var _createHistoryRecord2 = _interopRequireDefault(createHistoryRecord_1);

	  var _getDataFromHtml2 = _interopRequireDefault(getDataFromHtml_1);

	  var _fetch2 = _interopRequireDefault(fetch_1);

	  var _transitionEnd2 = _interopRequireDefault(transitionEnd_1);

	  var _getCurrentUrl2 = _interopRequireDefault(getCurrentUrl_1);

	  var _markSwupElements2 = _interopRequireDefault(markSwupElements_1);

	  var _Link2 = _interopRequireDefault(Link_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }

	  var classify = exports.classify = _classify2["default"];
	  var createHistoryRecord = exports.createHistoryRecord = _createHistoryRecord2["default"];
	  var getDataFromHtml = exports.getDataFromHtml = _getDataFromHtml2["default"];
	  var fetch = exports.fetch = _fetch2["default"];
	  var transitionEnd = exports.transitionEnd = _transitionEnd2["default"];
	  var getCurrentUrl = exports.getCurrentUrl = _getCurrentUrl2["default"];
	  var markSwupElements = exports.markSwupElements = _markSwupElements2["default"];
	  var Link = exports.Link = _Link2["default"];
	});
	unwrapExports(helpers);
	var helpers_1 = helpers.Link;
	var helpers_2 = helpers.markSwupElements;
	var helpers_3 = helpers.getCurrentUrl;
	var helpers_4 = helpers.transitionEnd;
	var helpers_5 = helpers.fetch;
	var helpers_6 = helpers.getDataFromHtml;
	var helpers_7 = helpers.createHistoryRecord;
	var helpers_8 = helpers.classify;

	var loadPage_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  var loadPage = function loadPage(data, popstate) {
	    var _this = this; // create array for storing animation promises


	    var animationPromises = [],
	        xhrPromise = void 0;

	    var animateOut = function animateOut() {
	      _this.triggerEvent('animationOutStart'); // handle classes


	      document.documentElement.classList.add('is-changing');
	      document.documentElement.classList.add('is-leaving');
	      document.documentElement.classList.add('is-animating');

	      if (popstate) {
	        document.documentElement.classList.add('is-popstate');
	      }

	      document.documentElement.classList.add('to-' + (0, helpers.classify)(data.url)); // animation promise stuff

	      animationPromises = _this.getAnimationPromises('out');
	      Promise.all(animationPromises).then(function () {
	        _this.triggerEvent('animationOutDone');
	      }); // create history record if this is not a popstate call

	      if (!popstate) {
	        // create pop element with or without anchor
	        var state = void 0;

	        if (_this.scrollToElement != null) {
	          state = data.url + _this.scrollToElement;
	        } else {
	          state = data.url;
	        }

	        (0, helpers.createHistoryRecord)(state);
	      }
	    };

	    this.triggerEvent('transitionStart', popstate); // set transition object

	    if (data.customTransition != null) {
	      this.updateTransition(window.location.pathname, data.url, data.customTransition);
	      document.documentElement.classList.add('to-' + (0, helpers.classify)(data.customTransition));
	    } else {
	      this.updateTransition(window.location.pathname, data.url);
	    } // start/skip animation


	    if (!popstate || this.options.animateHistoryBrowsing) {
	      animateOut();
	    } else {
	      this.triggerEvent('animationSkipped');
	    } // start/skip loading of page


	    if (this.cache.exists(data.url)) {
	      xhrPromise = new Promise(function (resolve) {
	        resolve();
	      });
	      this.triggerEvent('pageRetrievedFromCache');
	    } else {
	      if (!this.preloadPromise || this.preloadPromise.route != data.url) {
	        xhrPromise = new Promise(function (resolve, reject) {
	          (0, helpers.fetch)(_extends({}, data, {
	            headers: _this.options.requestHeaders
	          }), function (response) {
	            if (response.status === 500) {
	              _this.triggerEvent('serverError');

	              reject(data.url);
	              return;
	            } else {
	              // get json data
	              var page = _this.getPageData(response);

	              if (page != null) {
	                page.url = data.url;
	              } else {
	                reject(data.url);
	                return;
	              } // render page


	              _this.cache.cacheUrl(page);

	              _this.triggerEvent('pageLoaded');
	            }

	            resolve();
	          });
	        });
	      } else {
	        xhrPromise = this.preloadPromise;
	      }
	    } // when everything is ready, handle the outcome


	    Promise.all(animationPromises.concat([xhrPromise])).then(function () {
	      // render page
	      _this.renderPage(_this.cache.getPage(data.url), popstate);

	      _this.preloadPromise = null;
	    })["catch"](function (errorUrl) {
	      // rewrite the skipPopStateHandling function to redirect manually when the history.go is processed
	      _this.options.skipPopStateHandling = function () {
	        window.location = errorUrl;
	        return true;
	      }; // go back to the actual page were still at


	      window.history.go(-1);
	    });
	  };

	  exports["default"] = loadPage;
	});
	unwrapExports(loadPage_1);

	var renderPage_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  var renderPage = function renderPage(page, popstate) {
	    var _this = this;

	    document.documentElement.classList.remove('is-leaving'); // replace state in case the url was redirected

	    var link = new helpers.Link(page.responseURL);

	    if (window.location.pathname !== link.getPath()) {
	      window.history.replaceState({
	        url: link.getPath(),
	        random: Math.random(),
	        source: 'swup'
	      }, document.title, link.getPath()); // save new record for redirected url

	      this.cache.cacheUrl(_extends({}, page, {
	        url: link.getPath()
	      }));
	    } // only add for non-popstate transitions


	    if (!popstate || this.options.animateHistoryBrowsing) {
	      document.documentElement.classList.add('is-rendering');
	    }

	    this.triggerEvent('willReplaceContent', popstate); // replace blocks

	    for (var i = 0; i < page.blocks.length; i++) {
	      document.body.querySelector('[data-swup="' + i + '"]').outerHTML = page.blocks[i];
	    } // set title


	    document.title = page.title;
	    this.triggerEvent('contentReplaced', popstate);
	    this.triggerEvent('pageView', popstate); // empty cache if it's disabled (because pages could be preloaded and stuff)

	    if (!this.options.cache) {
	      this.cache.empty();
	    } // start animation IN


	    setTimeout(function () {
	      if (!popstate || _this.options.animateHistoryBrowsing) {
	        _this.triggerEvent('animationInStart');

	        document.documentElement.classList.remove('is-animating');
	      }
	    }, 10); // handle end of animation

	    var animationPromises = this.getAnimationPromises('in');

	    if (!popstate || this.options.animateHistoryBrowsing) {
	      Promise.all(animationPromises).then(function () {
	        _this.triggerEvent('animationInDone');

	        _this.triggerEvent('transitionEnd', popstate); // remove "to-{page}" classes


	        document.documentElement.className.split(' ').forEach(function (classItem) {
	          if (new RegExp('^to-').test(classItem) || classItem === 'is-changing' || classItem === 'is-rendering' || classItem === 'is-popstate') {
	            document.documentElement.classList.remove(classItem);
	          }
	        });
	      });
	    } else {
	      this.triggerEvent('transitionEnd', popstate);
	    } // reset scroll-to element


	    this.scrollToElement = null;
	  };

	  exports["default"] = renderPage;
	});
	unwrapExports(renderPage_1);

	var triggerEvent_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var triggerEvent = function triggerEvent(eventName, originalEvent) {
	    // call saved handlers with "on" method and pass originalEvent object if available
	    this._handlers[eventName].forEach(function (handler) {
	      try {
	        handler(originalEvent);
	      } catch (error) {
	        console.error(error);
	      }
	    }); // trigger event on document with prefix "swup:"


	    var event = new CustomEvent('swup:' + eventName, {
	      detail: eventName
	    });
	    document.dispatchEvent(event);
	  };

	  exports["default"] = triggerEvent;
	});
	unwrapExports(triggerEvent_1);

	var on_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var on = function on(event, handler) {
	    if (this._handlers[event]) {
	      this._handlers[event].push(handler);
	    } else {
	      console.warn("Unsupported event " + event + ".");
	    }
	  };

	  exports["default"] = on;
	});
	unwrapExports(on_1);

	var off_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var off = function off(event, handler) {
	    var _this = this;

	    if (event != null) {
	      if (handler != null) {
	        if (this._handlers[event] && this._handlers[event].filter(function (savedHandler) {
	          return savedHandler === handler;
	        }).length) {
	          var toRemove = this._handlers[event].filter(function (savedHandler) {
	            return savedHandler === handler;
	          })[0];

	          var index = this._handlers[event].indexOf(toRemove);

	          if (index > -1) {
	            this._handlers[event].splice(index, 1);
	          }
	        } else {
	          console.warn("Handler for event '" + event + "' no found.");
	        }
	      } else {
	        this._handlers[event] = [];
	      }
	    } else {
	      Object.keys(this._handlers).forEach(function (keys) {
	        _this._handlers[keys] = [];
	      });
	    }
	  };

	  exports["default"] = off;
	});
	unwrapExports(off_1);

	var updateTransition_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var updateTransition = function updateTransition(from, to, custom) {
	    // transition routes
	    this.transition = {
	      from: from,
	      to: to,
	      custom: custom
	    };
	  };

	  exports["default"] = updateTransition;
	});
	unwrapExports(updateTransition_1);

	var getAnimationPromises_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var getAnimationPromises = function getAnimationPromises() {
	    var promises = [];
	    var animatedElements = (0, utils.queryAll)(this.options.animationSelector);
	    animatedElements.forEach(function (element) {
	      var promise = new Promise(function (resolve) {
	        element.addEventListener((0, helpers.transitionEnd)(), function (event) {
	          if (element == event.target) {
	            resolve();
	          }
	        });
	      });
	      promises.push(promise);
	    });
	    return promises;
	  };

	  exports["default"] = getAnimationPromises;
	});
	unwrapExports(getAnimationPromises_1);

	var getPageData_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var getPageData = function getPageData(request) {
	    // this method can be replaced in case other content than html is expected to be received from server
	    // this function should always return {title, pageClass, originalContent, blocks, responseURL}
	    // in case page has invalid structure - return null
	    var html = request.responseText;
	    var pageObject = (0, helpers.getDataFromHtml)(html, this.options.containers);

	    if (pageObject) {
	      pageObject.responseURL = request.responseURL ? request.responseURL : window.location.href;
	    } else {
	      console.warn('Received page is invalid.');
	      return null;
	    }

	    return pageObject;
	  };

	  exports["default"] = getPageData;
	});
	unwrapExports(getPageData_1);

	var plugins = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var use = exports.use = function use(plugin) {
	    if (!plugin.isSwupPlugin) {
	      console.warn('Not swup plugin instance ' + plugin + '.');
	      return;
	    }

	    this.plugins.push(plugin);
	    plugin.swup = this;

	    if (typeof plugin._beforeMount === 'function') {
	      plugin._beforeMount();
	    }

	    plugin.mount();
	    return this.plugins;
	  };

	  var unuse = exports.unuse = function unuse(plugin) {
	    var pluginReference = void 0;

	    if (typeof plugin === 'string') {
	      pluginReference = this.plugins.find(function (p) {
	        return plugin === p.name;
	      });
	    } else {
	      pluginReference = plugin;
	    }

	    if (!pluginReference) {
	      console.warn('No such plugin.');
	      return;
	    }

	    pluginReference.unmount();

	    if (typeof pluginReference._afterUnmount === 'function') {
	      pluginReference._afterUnmount();
	    }

	    var index = this.plugins.indexOf(pluginReference);
	    this.plugins.splice(index, 1);
	    return this.plugins;
	  };

	  var findPlugin = exports.findPlugin = function findPlugin(pluginName) {
	    return this.plugins.find(function (p) {
	      return pluginName === p.name;
	    });
	  };
	});
	unwrapExports(plugins);
	var plugins_1 = plugins.use;
	var plugins_2 = plugins.unuse;
	var plugins_3 = plugins.findPlugin;

	var lib = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }(); // modules


	  var _delegate2 = _interopRequireDefault(delegate_1);

	  var _Cache2 = _interopRequireDefault(Cache_1);

	  var _loadPage2 = _interopRequireDefault(loadPage_1);

	  var _renderPage2 = _interopRequireDefault(renderPage_1);

	  var _triggerEvent2 = _interopRequireDefault(triggerEvent_1);

	  var _on2 = _interopRequireDefault(on_1);

	  var _off2 = _interopRequireDefault(off_1);

	  var _updateTransition2 = _interopRequireDefault(updateTransition_1);

	  var _getAnimationPromises2 = _interopRequireDefault(getAnimationPromises_1);

	  var _getPageData2 = _interopRequireDefault(getPageData_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var Swup = function () {
	    function Swup(setOptions) {
	      _classCallCheck(this, Swup); // default options


	      var defaults = {
	        animateHistoryBrowsing: false,
	        animationSelector: '[class*="transition-"]',
	        linkSelector: 'a[href^="' + window.location.origin + '"]:not([data-no-swup]), a[href^="/"]:not([data-no-swup]), a[href^="#"]:not([data-no-swup])',
	        cache: true,
	        containers: ['#swup'],
	        requestHeaders: {
	          'X-Requested-With': 'swup',
	          Accept: 'text/html, application/xhtml+xml'
	        },
	        plugins: [],
	        skipPopStateHandling: function skipPopStateHandling(event) {
	          return !(event.state && event.state.source === 'swup');
	        }
	      }; // merge options

	      var options = _extends({}, defaults, setOptions); // handler arrays


	      this._handlers = {
	        animationInDone: [],
	        animationInStart: [],
	        animationOutDone: [],
	        animationOutStart: [],
	        animationSkipped: [],
	        clickLink: [],
	        contentReplaced: [],
	        disabled: [],
	        enabled: [],
	        openPageInNewTab: [],
	        pageLoaded: [],
	        pageRetrievedFromCache: [],
	        pageView: [],
	        popState: [],
	        samePage: [],
	        samePageWithHash: [],
	        serverError: [],
	        transitionStart: [],
	        transitionEnd: [],
	        willReplaceContent: []
	      }; // variable for id of element to scroll to after render

	      this.scrollToElement = null; // variable for promise used for preload, so no new loading of the same page starts while page is loading

	      this.preloadPromise = null; // variable for save options

	      this.options = options; // variable for plugins array

	      this.plugins = []; // variable for current transition object

	      this.transition = {}; // variable for keeping event listeners from "delegate"

	      this.delegatedListeners = {}; // make modules accessible in instance

	      this.cache = new _Cache2["default"]();
	      this.cache.swup = this;
	      this.loadPage = _loadPage2["default"];
	      this.renderPage = _renderPage2["default"];
	      this.triggerEvent = _triggerEvent2["default"];
	      this.on = _on2["default"];
	      this.off = _off2["default"];
	      this.updateTransition = _updateTransition2["default"];
	      this.getAnimationPromises = _getAnimationPromises2["default"];
	      this.getPageData = _getPageData2["default"];

	      this.log = function () {}; // here so it can be used by plugins


	      this.use = plugins.use;
	      this.unuse = plugins.unuse;
	      this.findPlugin = plugins.findPlugin; // enable swup

	      this.enable();
	    }

	    _createClass(Swup, [{
	      key: 'enable',
	      value: function enable() {
	        var _this = this; // check for Promise support


	        if (typeof Promise === 'undefined') {
	          console.warn('Promise is not supported');
	          return;
	        } // add event listeners


	        this.delegatedListeners.click = (0, _delegate2["default"])(document, this.options.linkSelector, 'click', this.linkClickHandler.bind(this));
	        window.addEventListener('popstate', this.popStateHandler.bind(this)); // initial save to cache

	        var page = (0, helpers.getDataFromHtml)(document.documentElement.outerHTML, this.options.containers);
	        page.url = page.responseURL = (0, helpers.getCurrentUrl)();

	        if (this.options.cache) {
	          this.cache.cacheUrl(page);
	        } // mark swup blocks in html


	        (0, helpers.markSwupElements)(document.documentElement, this.options.containers); // mount plugins

	        this.options.plugins.forEach(function (plugin) {
	          _this.use(plugin);
	        }); // modify initial history record

	        window.history.replaceState(Object.assign({}, window.history.state, {
	          url: window.location.href,
	          random: Math.random(),
	          source: 'swup'
	        }), document.title, window.location.href); // trigger enabled event

	        this.triggerEvent('enabled'); // add swup-enabled class to html tag

	        document.documentElement.classList.add('swup-enabled'); // trigger page view event

	        this.triggerEvent('pageView');
	      }
	    }, {
	      key: 'destroy',
	      value: function destroy() {
	        var _this2 = this; // remove delegated listeners


	        this.delegatedListeners.click.destroy();
	        this.delegatedListeners.mouseover.destroy(); // remove popstate listener

	        window.removeEventListener('popstate', this.popStateHandler.bind(this)); // empty cache

	        this.cache.empty(); // unmount plugins

	        this.options.plugins.forEach(function (plugin) {
	          _this2.unuse(plugin);
	        }); // remove swup data atributes from blocks

	        (0, utils.queryAll)('[data-swup]').forEach(function (element) {
	          element.removeAttribute('data-swup');
	        }); // remove handlers

	        this.off(); // trigger disable event

	        this.triggerEvent('disabled'); // remove swup-enabled class from html tag

	        document.documentElement.classList.remove('swup-enabled');
	      }
	    }, {
	      key: 'linkClickHandler',
	      value: function linkClickHandler(event) {
	        // no control key pressed
	        if (!event.metaKey && !event.ctrlKey && !event.shiftKey && !event.altKey) {
	          // index of pressed button needs to be checked because Firefox triggers click on all mouse buttons
	          if (event.button === 0) {
	            this.triggerEvent('clickLink', event);
	            event.preventDefault();
	            var link = new helpers.Link(event.delegateTarget);

	            if (link.getAddress() == (0, helpers.getCurrentUrl)() || link.getAddress() == '') {
	              // link to the same URL
	              if (link.getHash() != '') {
	                // link to the same URL with hash
	                this.triggerEvent('samePageWithHash', event);
	                var element = document.querySelector(link.getHash());

	                if (element != null) {
	                  history.replaceState({
	                    url: link.getAddress() + link.getHash(),
	                    random: Math.random(),
	                    source: 'swup'
	                  }, document.title, link.getAddress() + link.getHash());
	                } else {
	                  // referenced element not found
	                  console.warn('Element for offset not found (' + link.getHash() + ')');
	                }
	              } else {
	                // link to the same URL without hash
	                this.triggerEvent('samePage', event);
	              }
	            } else {
	              // link to different url
	              if (link.getHash() != '') {
	                this.scrollToElement = link.getHash();
	              } // get custom transition from data


	              var customTransition = event.delegateTarget.getAttribute('data-swup-transition'); // load page

	              this.loadPage({
	                url: link.getAddress(),
	                customTransition: customTransition
	              }, false);
	            }
	          }
	        } else {
	          // open in new tab (do nothing)
	          this.triggerEvent('openPageInNewTab', event);
	        }
	      }
	    }, {
	      key: 'popStateHandler',
	      value: function popStateHandler(event) {
	        if (this.options.skipPopStateHandling(event)) return;
	        var link = new helpers.Link(event.state ? event.state.url : window.location.pathname);

	        if (link.getHash() !== '') {
	          this.scrollToElement = link.getHash();
	        } else {
	          event.preventDefault();
	        }

	        this.triggerEvent('popState', event);
	        this.loadPage({
	          url: link.getAddress()
	        }, event);
	      }
	    }]);

	    return Swup;
	  }();

	  exports["default"] = Swup;
	});
	var swup = unwrapExports(lib);

	var assign = Object.assign,
	    keys = Object.keys;
	var isArray = Array.isArray;
	 // Remove certain properties
	var _removeProps = function _removeProps(prop, obj) {
	  var newObj = assign({}, obj);
	  prop.forEach(function (key) {
	    return delete newObj[key];
	  });
	  return newObj;
	}; // Create an array of values that two array share in common

	var _log = function _log() {
	  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
	    args[_key2] = arguments[_key2];
	  }

	  return args.forEach(function (v) {
	    return console.log(v);
	  });
	}; // Capitalize strings

	var _capital = function _capital(val) {
	  return val[0].toUpperCase() + val.slice(1);
	}; // Test the type of a value

	var _is = function _is(val, type) {
	  return _typeof(val) == type;
	}; // Is Instance Of

	var _isInst = function _isInst(ctor, obj) {
	  return ctor instanceof obj;
	};

	var _type = function _type(type) {
	  // Tweak of _is
	  return function (val) {
	    return _is(val, type);
	  };
	};

	assign(_is, {
	  el: function el(_el) {
	    return _isInst(_el, Element) || _isInst(_el, Document);
	  },
	  arrlike: function arrlike(obj) {
	    var len = _is(obj.length, "number") && obj.length;
	    return len == 0 || len > 0 && len - 1 in obj;
	  },
	  num: function num(val) {
	    return !isNaN(val) && _type("number")(val);
	  },
	  "class": function _class(obj) {
	    return obj && obj._method && obj._class;
	  },
	  not: function not(type) {
	    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	      args[_key3 - 1] = arguments[_key3];
	    }

	    return !_is[type].apply(_is, args);
	  },
	  doc: function doc(ctor) {
	    return _isInst(ctor, Document);
	  },
	  def: function def(val) {
	    return !_is(val, "undefined");
	  },
	  win: function win(val) {
	    return val && val.window;
	  },
	  undef: _type("undefined"),
	  bool: _type("boolean"),
	  fn: _type("function"),
	  str: _type("string"),
	  obj: _type("object"),
	  nul: function nul(v) {
	    return v == null;
	  },
	  inst: _isInst,
	  arr: isArray,
	  _type: _type
	});
	/**
	 * @param  {Function} fn
	 * @param  {Array<any>} args
	 * @param  {Object} ctxt
	 */

	var _fnval = function _fnval(fn, args, ctxt) {
	  if (_is.not("fn", fn) || keys(fn.prototype || {}).length > 0) {
	    return fn;
	  }

	  return fn.apply(ctxt, args);
	};
	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	var ARGUMENT_NAMES = /(?:^|,)\s*([^\s,=]+)/g; // Argument names

	var _argNames = function _argNames(fn) {
	  var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
	  var argsList = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));
	  var result = argsList.match(ARGUMENT_NAMES),
	      stripped = [];
	  if (_is.nul(result)) return [];else {
	    for (var i = 0; i < result.length; i++) {
	      stripped.push(result[i].replace(/[\s,]/g, ''));
	    }

	    return stripped;
	  }
	}; // Get or set a value in an Object, based on it's path

	var _path = function _path(obj, path, val) {
	  path = path.toString().split(/[.,]/g);

	  if (_is.def(val)) {
	    if (path.length > 1) {
	      _path(obj[path.shift()], path, val);
	    } else {
	      obj[path[0]] = val;
	    }

	    return val;
	  } else {
	    path.forEach(function (_val) {
	      obj = obj[_val];
	    });
	  }

	  return obj;
	};
	/*
	    Builds on path and adds more power,
	    * Allows for multiple paths one value
	    * Using Objects as paths and setting the values individually
	    * Access values as an Array, from multiple paths
	*/

	var _attr = function _attr(obj, path, val) {
	  if (_is.obj(path) && _is.not("arr", path)) {
	    return assign(obj, path);
	  } else if (_is.arr(path)) {
	    if (_is.undef(val)) {
	      return path.map(function (_key) {
	        return _path(obj, _key);
	      });
	    } else {
	      path.forEach(function (_key) {
	        _path(obj, _key, val);
	      });
	    }
	  } else {
	    return _path(obj, path, val);
	  }

	  return obj;
	}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

	var _new = function _new(ctor, args) {
	  var F = function F() {
	    return ctor.apply(this, args);
	  };

	  F.prototype = ctor.prototype;
	  return new F();
	};

	var _attachProp = function _attachProp(where) {
	  var _prototype = where == "prototype";

	  return function (_obj) {
	    // If super class exists, set value of parent to `SuperClass` prototype
	    var parent = _obj.SuperClass && _obj.SuperClass.prototype;

	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    args.forEach(function (val) {
	      // Transform functions to Objects
	      var obj = _fnval(val, [_obj, _obj.constructor], _obj.prototype); // Iterate through Object


	      keys(obj).forEach(function (i) {
	        var _val = obj[i],
	            preVal = _val,
	            $$val = {
	          enumerable: true,
	          configurable: true
	        }; // If a Parent Class is Present, Set any argument/params named `$super` to the `Parent`

	        if (_is.fn(preVal)) {
	          if (parent && _argNames(preVal)[0] == "$super") {
	            // Let the first argument be the original value
	            _val = function _val() {
	              var parentFn = parent[i].bind(this);

	              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                args[_key2] = arguments[_key2];
	              }

	              return preVal.call.apply(preVal, [this, parentFn].concat(args));
	            };
	          } // For debugging purposes


	          _val.valueOf = preVal.valueOf.bind(preVal);
	          _val.toString = preVal.toString.bind(preVal);
	        }
	        /*
	            Allows the use of `Object.defineProperty`, if an Object has any of these
	            { $$prop: true, get: function () { ... }, set: function () { ... }, ... }
	        */


	        if (_is.def(_val) && _is.obj(_val) && _val.$$prop) {
	          assign($$val, {
	            set: function set(v) {
	              Object.defineProperty(this, i, {
	                value: v
	              });
	            },
	            get: function get() {
	              return this[i];
	            }
	          }, _removeProps(["$$prop"], _val));
	        } else {
	          assign($$val, {
	            writable: true,
	            value: _val
	          });
	        }

	        Object.defineProperty(_prototype ? _obj.prototype : _obj, i, $$val);
	      });
	    });
	    return _obj;
	  };
	}; // Set class prototype properties and methods

	var _method = _attachProp("prototype"); // Set static properties and methods

	var _static = _attachProp("static"); // Create a copy of static methods that can function as prototype methods

	var _alias = function _alias() {
	  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var opts = arguments.length > 1 ? arguments[1] : undefined;
	  var thisArg = opts && opts.thisArg || []; // This as first argument

	  var chain = opts && opts.chain || [];

	  var result = {},
	      _args;

	  var _loop = function _loop(i) {
	    var val = props[i],
	        toStr = void 0;

	    if (_is.fn(val)) {
	      // For more info: stackoverflow.com/questions/19696015
	      result[i] = function () {
	        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	          args[_key3] = arguments[_key3];
	        }

	        if (_is.fn(opts)) {
	          return opts.call.apply(opts, [this, val].concat(args));
	        } else {
	          _args = thisArg.includes(i) ? [this].concat(args) : args;

	          if (chain.includes(i)) {
	            val.apply(this, _args);
	            return this;
	          }

	          return val.apply(this, _args);
	        }
	      };

	      toStr = val.toString.bind(val);
	      result[i].toString = chain.includes(i) ? function () {
	        return "".concat(toStr(), " return this;");
	      } : toStr;
	      result[i].valueOf = val.valueOf.bind(val);
	    }
	  };

	  for (var i in props) {
	    _loop(i);
	  }

	  return result;
	}; // Easy access to configurable property attributes, like get, set, writeable, value etc...

	var _configAttr = function _configAttr() {
	  var attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "get";
	  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "function";
	  return function (val) {
	    var _val = val;

	    if (type == "function") {
	      _val = Function("with (this) return ".concat(val));
	      _val.toString = val.toString;
	    }

	    return _defineProperty({
	      $$prop: true
	    }, attr, _val);
	  };
	}; // Get and set property attributes

	var _get = _configAttr("get", "function");
	var _set = _configAttr("set", "function"); // Call the parent version of a method

	var _callsuper = function _callsuper(obj, method) {
	  var _parent = null,
	      $ = obj,
	      _const = $,
	      _super = _const.SuperClass; // Climb prototype chain to find method not equal to callee's method

	  while (_super) {
	    var _method2 = _super.prototype[method];

	    if ($[method] != _method2) {
	      _parent = _method2;
	      break;
	    }

	    $ = _super.prototype;
	    _const = $.constructor;
	    _super = _const.SuperClass;
	  }

	  if (!_parent) {
	    console.error("".concat(method, " method not found in prototype chain."));
	    return;
	  }

	  for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
	    args[_key4 - 2] = arguments[_key4];
	  }

	  return _parent.apply(obj, args);
	}; // All properties with the ability to use this as a first Argument

	var _thisArgs = {
	  fnval: _fnval,
	  argNames: _argNames,
	  method: _method,
	  "static": _static,
	  path: _path,
	  attr: _attr,
	  alias: _alias,
	  "new": _new,
	  callsuper: _callsuper
	};
	var props = {
	  _is: _is,
	  _fnval: _fnval,
	  _argNames: _argNames,
	  _method: _method,
	  _static: _static,
	  _path: _path,
	  _attr: _attr,
	  _alias: _alias,
	  _configAttr: _configAttr,
	  _get: _get,
	  _set: _set,
	  _new: _new,
	  _callsuper: _callsuper,
	  assign: assign,
	  keys: keys
	};
	props = keys(props).reduce(function (acc, i) {
	  i.charAt(0) == "_" && (acc[i.slice(1)] = props[i]);
	  return acc;
	}, props); // Properties methods with Class support

	var aliasMethods = _alias(_thisArgs, function (val) {
	  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    args[_key5 - 1] = arguments[_key5];
	  }

	  var _val = val.apply(this, [this].concat(args));

	  return _val;
	}); // Create classes

	var _create = function _create() {
	  var _$class2;

	  var _$class, subclass, parent, extend; // SubClass constructor


	  subclass = function subclass() {}; // Set parent constructor


	  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    args[_key6] = arguments[_key6];
	  }

	  if (_is.fn(args[0]) && keys(args[0].prototype || {}).length) {
	    parent = args.shift();
	  } // Class Object


	  _$class = function $class() {
	    for (var _len7 = arguments.length, _args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	      _args[_key7] = arguments[_key7];
	    }

	    // Current Class
	    if (!_is.inst(this, _$class)) {
	      return _new(_$class, _args);
	    }

	    this._args = _args; // Arguments
	    // Initialize Class

	    return this.init.apply(this, this._args);
	  };

	  _$class.SuperClass = parent; // Current Class's Parent if any

	  _$class.SubClasses = []; // List of SubClasses
	  // Extend parent class, if any

	  if (parent) {
	    subclass.prototype = parent.prototype;
	    _$class.prototype = new subclass();
	    if (!_is.arr(parent.SubClasses)) parent.SubClasses = [];
	    parent.SubClasses.push(_$class);
	  } // Easily extend this class to create new subclasses


	  extend = function extend() {
	    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
	      args[_key8] = arguments[_key8];
	    }

	    return _create.call.apply(_create, [this, this].concat(args));
	  }; // Extend Class


	  assign(_$class, aliasMethods, {
	    extend: extend,
	    create: _create
	  });
	  assign(_$class.prototype, _$class); // Add Methods to Class

	  (_$class2 = _$class).method.apply(_$class2, args); // Set Current class type


	  if (!_$class.prototype._class) {
	    _$class.prototype._class = "New Class";
	  }

	  if (!_$class.prototype.init) {
	    _$class.prototype.init = function () {};
	  } else {
	    // Set toString & toValue
	    _$class.toString = _$class.prototype.init.toString;
	    _$class.toValue = _$class.prototype.init.toValue;
	  } // Set Class constructor


	  _$class.prototype.constructor = _$class;
	  return _$class;
	}; // Create classes

	var _class = _create;
	assign(_class, props); // Extend _class

	/**
	 * @function getReferenceKey
	 *
	 * @description
	 * get the reference key for the circular value
	 *
	 * @param keys the keys to build the reference key from
	 * @param cutoff the maximum number of keys to include
	 * @returns the reference key
	 */
	function getReferenceKey(keys, cutoff) {
	  return keys.slice(0, cutoff).join('.') || '.';
	}
	/**
	 * @function getCutoff
	 *
	 * @description
	 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
	 *
	 * @param array the array to match the value in
	 * @param value the value to match
	 * @returns the matching index, or -1
	 */


	function getCutoff(array, value) {
	  var length = array.length;

	  for (var index = 0; index < length; ++index) {
	    if (array[index] === value) {
	      return index + 1;
	    }
	  }

	  return 0;
	}
	/**
	 * @function createReplacer
	 *
	 * @description
	 * create a replacer method that handles circular values
	 *
	 * @param [replacer] a custom replacer to use for non-circular values
	 * @param [circularReplacer] a custom replacer to use for circular methods
	 * @returns the value to stringify
	 */


	function createReplacer(replacer, circularReplacer) {
	  var hasReplacer = typeof replacer === 'function';
	  var hasCircularReplacer = typeof circularReplacer === 'function';
	  var cache = [];
	  var keys = [];
	  return function replace(key, value) {
	    if (_typeof(value) === 'object') {
	      if (cache.length) {
	        var thisCutoff = getCutoff(cache, this);

	        if (thisCutoff === 0) {
	          cache[cache.length] = this;
	        } else {
	          cache.splice(thisCutoff);
	          keys.splice(thisCutoff);
	        }

	        keys[keys.length] = key;
	        var valueCutoff = getCutoff(cache, value);

	        if (valueCutoff !== 0) {
	          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=" + getReferenceKey(keys, valueCutoff) + "]";
	        }
	      } else {
	        cache[0] = value;
	        keys[0] = key;
	      }
	    }

	    return hasReplacer ? replacer.call(this, key, value) : value;
	  };
	}
	/**
	 * @function stringify
	 *
	 * @description
	 * strinigifer that handles circular values
	 *
	 * @param the value to stringify
	 * @param [replacer] a custom replacer function for handling standard values
	 * @param [indent] the number of spaces to indent the output by
	 * @param [circularReplacer] a custom replacer function for handling circular values
	 * @returns the stringified output
	 */


	function stringify(value, replacer, indent, circularReplacer) {
	  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
	}

	var _stringify = function _stringify(obj) {
	  var fns = [];
	  var json = stringify(obj, function (key, val) {
	    if (typeof val == "function") {
	      fns.push(val.toString());
	      return "_";
	    }

	    return val;
	  }, 4);
	  return json.replace(/"_"/g, function () {
	    return fns.shift();
	  });
	};

	var stringify_1 = {
	  stringify: stringify,
	  _stringify: _stringify
	};
	var stringify_3 = stringify_1._stringify;

	var _get$1 = _class._get,
	    _is$1 = _class._is,
	    _argNames$1 = _class._argNames,
	    keys$1 = _class.keys;
	var _document = document,
	    readyState = _document.readyState; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

	var passive = false,
	    opts = {},
	    noop = function noop() {};

	opts = Object.defineProperty({}, "passive", {
	  get: function get() {
	    return passive = {
	      capture: false,
	      passive: true
	    };
	  }
	});
	window.addEventListener("PassiveEventTest", noop, opts);
	window.removeEventListener("PassiveEventsTest", noop, opts); // Event class

	var _event = _class({
	  _class: "Event",
	  // Class name
	  _events: {},
	  // Event info.
	  _emit: [],
	  // Store events set to be emitted
	  // Name of all event's
	  _names: _get$1("Object.keys(_events)"),
	  // Number of events
	  _eventCount: _get$1("_names.length"),
	  // Prepare the event
	  _preEvent: function _preEvent(evt) {
	    if (!this._events[evt]) // List of event's
	      {
	        this._events[evt] = [];
	      }

	    return this._events[evt];
	  },
	  // Apply event as object
	  _eventApp: function _eventApp(callback, scope, event) {
	    return {
	      callback: callback,
	      scope: scope || this,
	      event: event
	    };
	  },
	  // Add a listener for a given event
	  on: function on(evt, callback, scope) {
	    var $EvtApp, $evt;

	    if (_is$1.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is$1.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
	      evt = [evt];
	    } // Set evt to an array
	    // Loop through the list of events


	    keys$1(evt).forEach(function (key) {
	      $evt = evt[key];

	      if (_is$1.obj(evt) && _is$1.not("arr", evt)) {
	        $EvtApp = this._eventApp($evt, callback || this, key);

	        this._preEvent(key).push($EvtApp); // Set event list

	      } else {
	        $EvtApp = this._eventApp(callback, scope, $evt);

	        this._preEvent($evt).push($EvtApp); // Set event list

	      }
	    }, this);
	    return this;
	  },
	  // Call all function(s) within an event
	  emit: function emit(evt) {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var $Evt,
	        $args = args;

	    if (_is$1.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is$1.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is$1.not("arr", evt)) {
	      evt = [evt];
	    } // Set evt to an array
	    // Loop through the list of events


	    evt.forEach(function ($evt) {
	      $Evt = this._preEvent($evt);

	      if (!this._emit.includes($evt)) {
	        this._emit.push($evt);
	      }

	      $Evt.forEach(function (_evt) {
	        $args = args;

	        if (_argNames$1(_evt.callback)[0] == "$evt") {
	          $args = [_evt].concat(args);
	        }

	        _evt.callback.apply(_evt.scope, $args);
	      }, this);
	    }, this);
	    return this;
	  },
	  // Removes a listener for a given event
	  off: function off(evt, callback, scope) {
	    var $evt;

	    if (_is$1.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is$1.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
	      evt = [evt];
	    } // Set evt to an array


	    var _off = function ($evt, callback, scope) {
	      var _Evt = this._preEvent($evt);

	      if (callback) {
	        var i,
	            app = this._eventApp(callback, scope || this, $evt);

	        _Evt.forEach(function (val, _i) {
	          if (stringify_3(val) == stringify_3(app)) {
	            i = _i;
	          }
	        }, this);

	        if (i > -1) {
	          _Evt.splice(i, 1);
	        }
	      } else {
	        delete this._events[$evt];
	      }
	    }.bind(this);

	    keys$1(evt).forEach(function (key) {
	      $evt = evt[key];

	      if (_is$1.obj(evt) && _is$1.not("obj", evt)) {
	        _off(key, $evt, scope);
	      } else {
	        _off($evt, callback, scope);
	      }
	    }, this);
	    return this;
	  },
	  // Adds a one time event listener for a given event
	  once: function once(evt, callback, scope) {
	    if (_is$1.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is$1.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
	      evt = [evt];
	    } // Set evt to an array


	    var $Fn = function $Fn() {
	      this.off(evt, $Fn, scope);

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      callback.apply(scope, args);
	    };

	    this.on(evt, $Fn, scope);
	    return this;
	  },
	  // List's all listeners for a given event
	  listeners: function listeners(evt) {
	    var $Evt = this._preEvent(evt);

	    if (!$Evt.length) {
	      return [];
	    }

	    return $Evt.map(function (val) {
	      return val.callback;
	    });
	  },
	  // List's all listener values for a given event
	  listenerValues: function listenerValues(evt) {
	    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	      args[_key3 - 1] = arguments[_key3];
	    }

	    var $Evt = this._preEvent(evt);

	    if (!$Evt.length) {
	      return [];
	    }

	    return $Evt.map(function (val) {
	      var _val$callback;

	      return (_val$callback = val.callback).call.apply(_val$callback, [val.scope].concat(args));
	    });
	  },
	  // Clear all events
	  clear: function clear() {
	    this._eventCount = 0;
	    this._events = {};
	    return this;
	  },
	  // Clear all events
	  clearListeners: function clearListeners(evt) {
	    this._events[evt] = [];
	    return this;
	  },
	  // Alias for the `on` method
	  add: _get$1("on"),
	  bind: _get$1("on"),
	  // Alias for the `off` method
	  remove: _get$1("off"),
	  unbind: _get$1("off"),
	  // Alias for the `emit` method
	  fire: _get$1("emit"),
	  trigger: _get$1("emit"),
	  // Alias for the `listeners` method
	  callbacks: _get$1("listeners")
	})["static"]({
	  nativeEvents: "ready load blur focus focusin focusout resize click scroll dblclick\n    mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave\n    change select submit keydown keypress keyup contextmenu".split(" "),
	  applyNative: function applyNative(evt, el, ev, i) {
	    var action = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "addEventListener";
	    if (!ev.length) return;

	    var _emit = function _emit(_ev) {
	      return function (e) {
	        return evt.emit(_ev, e, evt, i);
	      };
	    };

	    if (/ready|load/.test(ev)) {
	      if (!/in/.test(readyState)) {
	        _emit("ready load")();
	      } else if (document.addEventListener) {
	        document.addEventListener('DOMContentLoaded', _emit("ready load"));
	      } else {
	        document.attachEvent('onreadystatechange', function (e) {
	          if (!/in/.test(readyState)) _emit("ready load")(e);
	        });
	      }
	    } else {
	      ev.split(" ").forEach(function (val) {
	        el[action](val, _emit(ev), ev == "scroll" ? passive : {});
	      });
	    }
	  }
	});

	/*
	 * anime.js v3.1.0
	 * (c) 2019 Julian Garnier
	 * Released under the MIT license
	 * animejs.com
	 */
	// Defaults
	var defaultInstanceSettings = {
	  update: null,
	  begin: null,
	  loopBegin: null,
	  changeBegin: null,
	  change: null,
	  changeComplete: null,
	  loopComplete: null,
	  complete: null,
	  loop: 1,
	  direction: 'normal',
	  autoplay: true,
	  timelineOffset: 0
	};
	var defaultTweenSettings = {
	  duration: 1000,
	  delay: 0,
	  endDelay: 0,
	  easing: 'easeOutElastic(1, .5)',
	  round: 0
	};
	var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective']; // Caching

	var cache = {
	  CSS: {},
	  springs: {}
	}; // Utils

	function minMax(val, min, max) {
	  return Math.min(Math.max(val, min), max);
	}

	function stringContains(str, text) {
	  return str.indexOf(text) > -1;
	}

	function applyArguments(func, args) {
	  return func.apply(null, args);
	}

	var is = {
	  arr: function arr(a) {
	    return Array.isArray(a);
	  },
	  obj: function obj(a) {
	    return stringContains(Object.prototype.toString.call(a), 'Object');
	  },
	  pth: function pth(a) {
	    return is.obj(a) && a.hasOwnProperty('totalLength');
	  },
	  svg: function svg(a) {
	    return a instanceof SVGElement;
	  },
	  inp: function inp(a) {
	    return a instanceof HTMLInputElement;
	  },
	  dom: function dom(a) {
	    return a.nodeType || is.svg(a);
	  },
	  str: function str(a) {
	    return typeof a === 'string';
	  },
	  fnc: function fnc(a) {
	    return typeof a === 'function';
	  },
	  und: function und(a) {
	    return typeof a === 'undefined';
	  },
	  hex: function hex(a) {
	    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
	  },
	  rgb: function rgb(a) {
	    return /^rgb/.test(a);
	  },
	  hsl: function hsl(a) {
	    return /^hsl/.test(a);
	  },
	  col: function col(a) {
	    return is.hex(a) || is.rgb(a) || is.hsl(a);
	  },
	  key: function key(a) {
	    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
	  }
	}; // Easings

	function parseEasingParameters(string) {
	  var match = /\(([^)]+)\)/.exec(string);
	  return match ? match[1].split(',').map(function (p) {
	    return parseFloat(p);
	  }) : [];
	} // Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


	function spring(string, duration) {
	  var params = parseEasingParameters(string);
	  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
	  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
	  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
	  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
	  var w0 = Math.sqrt(stiffness / mass);
	  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
	  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
	  var a = 1;
	  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

	  function solver(t) {
	    var progress = duration ? duration * t / 1000 : t;

	    if (zeta < 1) {
	      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
	    } else {
	      progress = (a + b * progress) * Math.exp(-progress * w0);
	    }

	    if (t === 0 || t === 1) {
	      return t;
	    }

	    return 1 - progress;
	  }

	  function getDuration() {
	    var cached = cache.springs[string];

	    if (cached) {
	      return cached;
	    }

	    var frame = 1 / 6;
	    var elapsed = 0;
	    var rest = 0;

	    while (true) {
	      elapsed += frame;

	      if (solver(elapsed) === 1) {
	        rest++;

	        if (rest >= 16) {
	          break;
	        }
	      } else {
	        rest = 0;
	      }
	    }

	    var duration = elapsed * frame * 1000;
	    cache.springs[string] = duration;
	    return duration;
	  }

	  return duration ? solver : getDuration;
	} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


	function steps(steps) {
	  if (steps === void 0) steps = 10;
	  return function (t) {
	    return Math.round(t * steps) * (1 / steps);
	  };
	} // BezierEasing https://github.com/gre/bezier-easing


	var bezier = function () {
	  var kSplineTableSize = 11;
	  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	  function A(aA1, aA2) {
	    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
	  }

	  function B(aA1, aA2) {
	    return 3.0 * aA2 - 6.0 * aA1;
	  }

	  function C(aA1) {
	    return 3.0 * aA1;
	  }

	  function calcBezier(aT, aA1, aA2) {
	    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	  }

	  function getSlope(aT, aA1, aA2) {
	    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	  }

	  function binarySubdivide(aX, aA, aB, mX1, mX2) {
	    var currentX,
	        currentT,
	        i = 0;

	    do {
	      currentT = aA + (aB - aA) / 2.0;
	      currentX = calcBezier(currentT, mX1, mX2) - aX;

	      if (currentX > 0.0) {
	        aB = currentT;
	      } else {
	        aA = currentT;
	      }
	    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

	    return currentT;
	  }

	  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
	    for (var i = 0; i < 4; ++i) {
	      var currentSlope = getSlope(aGuessT, mX1, mX2);

	      if (currentSlope === 0.0) {
	        return aGuessT;
	      }

	      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	      aGuessT -= currentX / currentSlope;
	    }

	    return aGuessT;
	  }

	  function bezier(mX1, mY1, mX2, mY2) {
	    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
	      return;
	    }

	    var sampleValues = new Float32Array(kSplineTableSize);

	    if (mX1 !== mY1 || mX2 !== mY2) {
	      for (var i = 0; i < kSplineTableSize; ++i) {
	        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	      }
	    }

	    function getTForX(aX) {
	      var intervalStart = 0;
	      var currentSample = 1;
	      var lastSample = kSplineTableSize - 1;

	      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	        intervalStart += kSampleStepSize;
	      }

	      --currentSample;
	      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	      var guessForT = intervalStart + dist * kSampleStepSize;
	      var initialSlope = getSlope(guessForT, mX1, mX2);

	      if (initialSlope >= 0.001) {
	        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	      } else if (initialSlope === 0.0) {
	        return guessForT;
	      } else {
	        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	      }
	    }

	    return function (x) {
	      if (mX1 === mY1 && mX2 === mY2) {
	        return x;
	      }

	      if (x === 0 || x === 1) {
	        return x;
	      }

	      return calcBezier(getTForX(x), mY1, mY2);
	    };
	  }

	  return bezier;
	}();

	var penner = function () {
	  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
	  var eases = {
	    linear: function linear() {
	      return function (t) {
	        return t;
	      };
	    }
	  };
	  var functionEasings = {
	    Sine: function Sine() {
	      return function (t) {
	        return 1 - Math.cos(t * Math.PI / 2);
	      };
	    },
	    Circ: function Circ() {
	      return function (t) {
	        return 1 - Math.sqrt(1 - t * t);
	      };
	    },
	    Back: function Back() {
	      return function (t) {
	        return t * t * (3 * t - 2);
	      };
	    },
	    Bounce: function Bounce() {
	      return function (t) {
	        var pow2,
	            b = 4;

	        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

	        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
	      };
	    },
	    Elastic: function Elastic(amplitude, period) {
	      if (amplitude === void 0) amplitude = 1;
	      if (period === void 0) period = .5;
	      var a = minMax(amplitude, 1, 10);
	      var p = minMax(period, .1, 2);
	      return function (t) {
	        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
	      };
	    }
	  };
	  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
	  baseEasings.forEach(function (name, i) {
	    functionEasings[name] = function () {
	      return function (t) {
	        return Math.pow(t, i + 2);
	      };
	    };
	  });
	  Object.keys(functionEasings).forEach(function (name) {
	    var easeIn = functionEasings[name];
	    eases['easeIn' + name] = easeIn;

	    eases['easeOut' + name] = function (a, b) {
	      return function (t) {
	        return 1 - easeIn(a, b)(1 - t);
	      };
	    };

	    eases['easeInOut' + name] = function (a, b) {
	      return function (t) {
	        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
	      };
	    };
	  });
	  return eases;
	}();

	function parseEasings(easing, duration) {
	  if (is.fnc(easing)) {
	    return easing;
	  }

	  var name = easing.split('(')[0];
	  var ease = penner[name];
	  var args = parseEasingParameters(easing);

	  switch (name) {
	    case 'spring':
	      return spring(easing, duration);

	    case 'cubicBezier':
	      return applyArguments(bezier, args);

	    case 'steps':
	      return applyArguments(steps, args);

	    default:
	      return applyArguments(ease, args);
	  }
	} // Strings


	function selectString(str) {
	  try {
	    var nodes = document.querySelectorAll(str);
	    return nodes;
	  } catch (e) {
	    return;
	  }
	} // Arrays


	function filterArray(arr, callback) {
	  var len = arr.length;
	  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	  var result = [];

	  for (var i = 0; i < len; i++) {
	    if (i in arr) {
	      var val = arr[i];

	      if (callback.call(thisArg, val, i, arr)) {
	        result.push(val);
	      }
	    }
	  }

	  return result;
	}

	function flattenArray(arr) {
	  return arr.reduce(function (a, b) {
	    return a.concat(is.arr(b) ? flattenArray(b) : b);
	  }, []);
	}

	function toArray(o) {
	  if (is.arr(o)) {
	    return o;
	  }

	  if (is.str(o)) {
	    o = selectString(o) || o;
	  }

	  if (o instanceof NodeList || o instanceof HTMLCollection) {
	    return [].slice.call(o);
	  }

	  return [o];
	}

	function arrayContains(arr, val) {
	  return arr.some(function (a) {
	    return a === val;
	  });
	} // Objects


	function cloneObject(o) {
	  var clone = {};

	  for (var p in o) {
	    clone[p] = o[p];
	  }

	  return clone;
	}

	function replaceObjectProps(o1, o2) {
	  var o = cloneObject(o1);

	  for (var p in o1) {
	    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
	  }

	  return o;
	}

	function mergeObjects(o1, o2) {
	  var o = cloneObject(o1);

	  for (var p in o2) {
	    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
	  }

	  return o;
	} // Colors


	function rgbToRgba(rgbValue) {
	  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
	  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
	}

	function hexToRgba(hexValue) {
	  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	  var hex = hexValue.replace(rgx, function (m, r, g, b) {
	    return r + r + g + g + b + b;
	  });
	  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	  var r = parseInt(rgb[1], 16);
	  var g = parseInt(rgb[2], 16);
	  var b = parseInt(rgb[3], 16);
	  return "rgba(" + r + "," + g + "," + b + ",1)";
	}

	function hslToRgba(hslValue) {
	  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
	  var h = parseInt(hsl[1], 10) / 360;
	  var s = parseInt(hsl[2], 10) / 100;
	  var l = parseInt(hsl[3], 10) / 100;
	  var a = hsl[4] || 1;

	  function hue2rgb(p, q, t) {
	    if (t < 0) {
	      t += 1;
	    }

	    if (t > 1) {
	      t -= 1;
	    }

	    if (t < 1 / 6) {
	      return p + (q - p) * 6 * t;
	    }

	    if (t < 1 / 2) {
	      return q;
	    }

	    if (t < 2 / 3) {
	      return p + (q - p) * (2 / 3 - t) * 6;
	    }

	    return p;
	  }

	  var r, g, b;

	  if (s == 0) {
	    r = g = b = l;
	  } else {
	    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    var p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1 / 3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - 1 / 3);
	  }

	  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
	}

	function colorToRgb(val) {
	  if (is.rgb(val)) {
	    return rgbToRgba(val);
	  }

	  if (is.hex(val)) {
	    return hexToRgba(val);
	  }

	  if (is.hsl(val)) {
	    return hslToRgba(val);
	  }
	} // Units


	function getUnit(val) {
	  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

	  if (split) {
	    return split[1];
	  }
	}

	function getTransformUnit(propName) {
	  if (stringContains(propName, 'translate') || propName === 'perspective') {
	    return 'px';
	  }

	  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
	    return 'deg';
	  }
	} // Values


	function getFunctionValue(val, animatable) {
	  if (!is.fnc(val)) {
	    return val;
	  }

	  return val(animatable.target, animatable.id, animatable.total);
	}

	function getAttribute(el, prop) {
	  return el.getAttribute(prop);
	}

	function convertPxToUnit(el, value, unit) {
	  var valueUnit = getUnit(value);

	  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
	    return value;
	  }

	  var cached = cache.CSS[value + unit];

	  if (!is.und(cached)) {
	    return cached;
	  }

	  var baseline = 100;
	  var tempEl = document.createElement(el.tagName);
	  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
	  parentEl.appendChild(tempEl);
	  tempEl.style.position = 'absolute';
	  tempEl.style.width = baseline + unit;
	  var factor = baseline / tempEl.offsetWidth;
	  parentEl.removeChild(tempEl);
	  var convertedUnit = factor * parseFloat(value);
	  cache.CSS[value + unit] = convertedUnit;
	  return convertedUnit;
	}

	function getCSSValue(el, prop, unit) {
	  if (prop in el.style) {
	    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
	    return unit ? convertPxToUnit(el, value, unit) : value;
	  }
	}

	function getAnimationType(el, prop) {
	  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop])) {
	    return 'attribute';
	  }

	  if (is.dom(el) && arrayContains(validTransforms, prop)) {
	    return 'transform';
	  }

	  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
	    return 'css';
	  }

	  if (el[prop] != null) {
	    return 'object';
	  }
	}

	function getElementTransforms(el) {
	  if (!is.dom(el)) {
	    return;
	  }

	  var str = el.style.transform || '';
	  var reg = /(\w+)\(([^)]*)\)/g;
	  var transforms = new Map();
	  var m;

	  while (m = reg.exec(str)) {
	    transforms.set(m[1], m[2]);
	  }

	  return transforms;
	}

	function getTransformValue(el, propName, animatable, unit) {
	  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
	  var value = getElementTransforms(el).get(propName) || defaultVal;

	  if (animatable) {
	    animatable.transforms.list.set(propName, value);
	    animatable.transforms['last'] = propName;
	  }

	  return unit ? convertPxToUnit(el, value, unit) : value;
	}

	function getOriginalTargetValue(target, propName, unit, animatable) {
	  switch (getAnimationType(target, propName)) {
	    case 'transform':
	      return getTransformValue(target, propName, animatable, unit);

	    case 'css':
	      return getCSSValue(target, propName, unit);

	    case 'attribute':
	      return getAttribute(target, propName);

	    default:
	      return target[propName] || 0;
	  }
	}

	function getRelativeValue(to, from) {
	  var operator = /^(\*=|\+=|-=)/.exec(to);

	  if (!operator) {
	    return to;
	  }

	  var u = getUnit(to) || 0;
	  var x = parseFloat(from);
	  var y = parseFloat(to.replace(operator[0], ''));

	  switch (operator[0][0]) {
	    case '+':
	      return x + y + u;

	    case '-':
	      return x - y + u;

	    case '*':
	      return x * y + u;
	  }
	}

	function validateValue(val, unit) {
	  if (is.col(val)) {
	    return colorToRgb(val);
	  }

	  if (/\s/g.test(val)) {
	    return val;
	  }

	  var originalUnit = getUnit(val);
	  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

	  if (unit) {
	    return unitLess + unit;
	  }

	  return unitLess;
	} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
	// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


	function getDistance(p1, p2) {
	  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
	}

	function getCircleLength(el) {
	  return Math.PI * 2 * getAttribute(el, 'r');
	}

	function getRectLength(el) {
	  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
	}

	function getLineLength(el) {
	  return getDistance({
	    x: getAttribute(el, 'x1'),
	    y: getAttribute(el, 'y1')
	  }, {
	    x: getAttribute(el, 'x2'),
	    y: getAttribute(el, 'y2')
	  });
	}

	function getPolylineLength(el) {
	  var points = el.points;
	  var totalLength = 0;
	  var previousPos;

	  for (var i = 0; i < points.numberOfItems; i++) {
	    var currentPos = points.getItem(i);

	    if (i > 0) {
	      totalLength += getDistance(previousPos, currentPos);
	    }

	    previousPos = currentPos;
	  }

	  return totalLength;
	}

	function getPolygonLength(el) {
	  var points = el.points;
	  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
	} // Path animation


	function getTotalLength(el) {
	  if (el.getTotalLength) {
	    return el.getTotalLength();
	  }

	  switch (el.tagName.toLowerCase()) {
	    case 'circle':
	      return getCircleLength(el);

	    case 'rect':
	      return getRectLength(el);

	    case 'line':
	      return getLineLength(el);

	    case 'polyline':
	      return getPolylineLength(el);

	    case 'polygon':
	      return getPolygonLength(el);
	  }
	}

	function setDashoffset(el) {
	  var pathLength = getTotalLength(el);
	  el.setAttribute('stroke-dasharray', pathLength);
	  return pathLength;
	} // Motion path


	function getParentSvgEl(el) {
	  var parentEl = el.parentNode;

	  while (is.svg(parentEl)) {
	    if (!is.svg(parentEl.parentNode)) {
	      break;
	    }

	    parentEl = parentEl.parentNode;
	  }

	  return parentEl;
	}

	function getParentSvg(pathEl, svgData) {
	  var svg = svgData || {};
	  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
	  var rect = parentSvgEl.getBoundingClientRect();
	  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
	  var width = rect.width;
	  var height = rect.height;
	  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
	  return {
	    el: parentSvgEl,
	    viewBox: viewBox,
	    x: viewBox[0] / 1,
	    y: viewBox[1] / 1,
	    w: width / viewBox[2],
	    h: height / viewBox[3]
	  };
	}

	function getPath(path, percent) {
	  var pathEl = is.str(path) ? selectString(path)[0] : path;
	  var p = percent || 100;
	  return function (property) {
	    return {
	      property: property,
	      el: pathEl,
	      svg: getParentSvg(pathEl),
	      totalLength: getTotalLength(pathEl) * (p / 100)
	    };
	  };
	}

	function getPathProgress(path, progress) {
	  function point(offset) {
	    if (offset === void 0) offset = 0;
	    var l = progress + offset >= 1 ? progress + offset : 0;
	    return path.el.getPointAtLength(l);
	  }

	  var svg = getParentSvg(path.el, path.svg);
	  var p = point();
	  var p0 = point(-1);
	  var p1 = point(+1);

	  switch (path.property) {
	    case 'x':
	      return (p.x - svg.x) * svg.w;

	    case 'y':
	      return (p.y - svg.y) * svg.h;

	    case 'angle':
	      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
	  }
	} // Decompose value


	function decomposeValue(val, unit) {
	  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
	  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
	  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

	  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
	  return {
	    original: value,
	    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
	    strings: is.str(val) || unit ? value.split(rgx) : []
	  };
	} // Animatables


	function parseTargets(targets) {
	  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
	  return filterArray(targetsArray, function (item, pos, self) {
	    return self.indexOf(item) === pos;
	  });
	}

	function getAnimatables(targets) {
	  var parsed = parseTargets(targets);
	  return parsed.map(function (t, i) {
	    return {
	      target: t,
	      id: i,
	      total: parsed.length,
	      transforms: {
	        list: getElementTransforms(t)
	      }
	    };
	  });
	} // Properties


	function normalizePropertyTweens(prop, tweenSettings) {
	  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

	  if (/^spring/.test(settings.easing)) {
	    settings.duration = spring(settings.easing);
	  }

	  if (is.arr(prop)) {
	    var l = prop.length;
	    var isFromTo = l === 2 && !is.obj(prop[0]);

	    if (!isFromTo) {
	      // Duration divided by the number of tweens
	      if (!is.fnc(tweenSettings.duration)) {
	        settings.duration = tweenSettings.duration / l;
	      }
	    } else {
	      // Transform [from, to] values shorthand to a valid tween value
	      prop = {
	        value: prop
	      };
	    }
	  }

	  var propArray = is.arr(prop) ? prop : [prop];
	  return propArray.map(function (v, i) {
	    var obj = is.obj(v) && !is.pth(v) ? v : {
	      value: v
	    }; // Default delay value should only be applied to the first tween

	    if (is.und(obj.delay)) {
	      obj.delay = !i ? tweenSettings.delay : 0;
	    } // Default endDelay value should only be applied to the last tween


	    if (is.und(obj.endDelay)) {
	      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
	    }

	    return obj;
	  }).map(function (k) {
	    return mergeObjects(k, settings);
	  });
	}

	function flattenKeyframes(keyframes) {
	  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
	    return Object.keys(key);
	  })), function (p) {
	    return is.key(p);
	  }).reduce(function (a, b) {
	    if (a.indexOf(b) < 0) {
	      a.push(b);
	    }

	    return a;
	  }, []);
	  var properties = {};

	  var loop = function loop(i) {
	    var propName = propertyNames[i];
	    properties[propName] = keyframes.map(function (key) {
	      var newKey = {};

	      for (var p in key) {
	        if (is.key(p)) {
	          if (p == propName) {
	            newKey.value = key[p];
	          }
	        } else {
	          newKey[p] = key[p];
	        }
	      }

	      return newKey;
	    });
	  };

	  for (var i = 0; i < propertyNames.length; i++) {
	    loop(i);
	  }

	  return properties;
	}

	function getProperties(tweenSettings, params) {
	  var properties = [];
	  var keyframes = params.keyframes;

	  if (keyframes) {
	    params = mergeObjects(flattenKeyframes(keyframes), params);
	  }

	  for (var p in params) {
	    if (is.key(p)) {
	      properties.push({
	        name: p,
	        tweens: normalizePropertyTweens(params[p], tweenSettings)
	      });
	    }
	  }

	  return properties;
	} // Tweens


	function normalizeTweenValues(tween, animatable) {
	  var t = {};

	  for (var p in tween) {
	    var value = getFunctionValue(tween[p], animatable);

	    if (is.arr(value)) {
	      value = value.map(function (v) {
	        return getFunctionValue(v, animatable);
	      });

	      if (value.length === 1) {
	        value = value[0];
	      }
	    }

	    t[p] = value;
	  }

	  t.duration = parseFloat(t.duration);
	  t.delay = parseFloat(t.delay);
	  return t;
	}

	function normalizeTweens(prop, animatable) {
	  var previousTween;
	  return prop.tweens.map(function (t) {
	    var tween = normalizeTweenValues(t, animatable);
	    var tweenValue = tween.value;
	    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
	    var toUnit = getUnit(to);
	    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
	    var previousValue = previousTween ? previousTween.to.original : originalValue;
	    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
	    var fromUnit = getUnit(from) || getUnit(originalValue);
	    var unit = toUnit || fromUnit;

	    if (is.und(to)) {
	      to = previousValue;
	    }

	    tween.from = decomposeValue(from, unit);
	    tween.to = decomposeValue(getRelativeValue(to, from), unit);
	    tween.start = previousTween ? previousTween.end : 0;
	    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
	    tween.easing = parseEasings(tween.easing, tween.duration);
	    tween.isPath = is.pth(tweenValue);
	    tween.isColor = is.col(tween.from.original);

	    if (tween.isColor) {
	      tween.round = 1;
	    }

	    previousTween = tween;
	    return tween;
	  });
	} // Tween progress


	var setProgressValue = {
	  css: function css(t, p, v) {
	    return t.style[p] = v;
	  },
	  attribute: function attribute(t, p, v) {
	    return t.setAttribute(p, v);
	  },
	  object: function object(t, p, v) {
	    return t[p] = v;
	  },
	  transform: function transform(t, p, v, transforms, manual) {
	    transforms.list.set(p, v);

	    if (p === transforms.last || manual) {
	      var str = '';
	      transforms.list.forEach(function (value, prop) {
	        str += prop + "(" + value + ") ";
	      });
	      t.style.transform = str;
	    }
	  }
	}; // Set Value helper

	function setTargetsValue(targets, properties) {
	  var animatables = getAnimatables(targets);
	  animatables.forEach(function (animatable) {
	    for (var property in properties) {
	      var value = getFunctionValue(properties[property], animatable);
	      var target = animatable.target;
	      var valueUnit = getUnit(value);
	      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
	      var unit = valueUnit || getUnit(originalValue);
	      var to = getRelativeValue(validateValue(value, unit), originalValue);
	      var animType = getAnimationType(target, property);
	      setProgressValue[animType](target, property, to, animatable.transforms, true);
	    }
	  });
	} // Animations


	function createAnimation(animatable, prop) {
	  var animType = getAnimationType(animatable.target, prop.name);

	  if (animType) {
	    var tweens = normalizeTweens(prop, animatable);
	    var lastTween = tweens[tweens.length - 1];
	    return {
	      type: animType,
	      property: prop.name,
	      animatable: animatable,
	      tweens: tweens,
	      duration: lastTween.end,
	      delay: tweens[0].delay,
	      endDelay: lastTween.endDelay
	    };
	  }
	}

	function getAnimations(animatables, properties) {
	  return filterArray(flattenArray(animatables.map(function (animatable) {
	    return properties.map(function (prop) {
	      return createAnimation(animatable, prop);
	    });
	  })), function (a) {
	    return !is.und(a);
	  });
	} // Create Instance


	function getInstanceTimings(animations, tweenSettings) {
	  var animLength = animations.length;

	  var getTlOffset = function getTlOffset(anim) {
	    return anim.timelineOffset ? anim.timelineOffset : 0;
	  };

	  var timings = {};
	  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
	    return getTlOffset(anim) + anim.duration;
	  })) : tweenSettings.duration;
	  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
	    return getTlOffset(anim) + anim.delay;
	  })) : tweenSettings.delay;
	  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
	    return getTlOffset(anim) + anim.duration - anim.endDelay;
	  })) : tweenSettings.endDelay;
	  return timings;
	}

	var instanceID = 0;

	function createNewInstance(params) {
	  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
	  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
	  var properties = getProperties(tweenSettings, params);
	  var animatables = getAnimatables(params.targets);
	  var animations = getAnimations(animatables, properties);
	  var timings = getInstanceTimings(animations, tweenSettings);
	  var id = instanceID;
	  instanceID++;
	  return mergeObjects(instanceSettings, {
	    id: id,
	    children: [],
	    animatables: animatables,
	    animations: animations,
	    duration: timings.duration,
	    delay: timings.delay,
	    endDelay: timings.endDelay
	  });
	} // Core


	var activeInstances = [];
	var pausedInstances = [];
	var raf;

	var engine = function () {
	  function play() {
	    raf = requestAnimationFrame(step);
	  }

	  function step(t) {
	    var activeInstancesLength = activeInstances.length;

	    if (activeInstancesLength) {
	      var i = 0;

	      while (i < activeInstancesLength) {
	        var activeInstance = activeInstances[i];

	        if (!activeInstance.paused) {
	          activeInstance.tick(t);
	        } else {
	          var instanceIndex = activeInstances.indexOf(activeInstance);

	          if (instanceIndex > -1) {
	            activeInstances.splice(instanceIndex, 1);
	            activeInstancesLength = activeInstances.length;
	          }
	        }

	        i++;
	      }

	      play();
	    } else {
	      raf = cancelAnimationFrame(raf);
	    }
	  }

	  return play;
	}();

	function handleVisibilityChange() {
	  if (document.hidden) {
	    activeInstances.forEach(function (ins) {
	      return ins.pause();
	    });
	    pausedInstances = activeInstances.slice(0);
	    anime.running = activeInstances = [];
	  } else {
	    pausedInstances.forEach(function (ins) {
	      return ins.play();
	    });
	  }
	}

	if (typeof document !== 'undefined') {
	  document.addEventListener('visibilitychange', handleVisibilityChange);
	} // Public Instance


	function anime(params) {
	  if (params === void 0) params = {};
	  var startTime = 0,
	      lastTime = 0,
	      now = 0;
	  var children,
	      childrenLength = 0;
	  var resolve = null;

	  function makePromise(instance) {
	    var promise = window.Promise && new Promise(function (_resolve) {
	      return resolve = _resolve;
	    });
	    instance.finished = promise;
	    return promise;
	  }

	  var instance = createNewInstance(params);
	  var promise = makePromise(instance);

	  function toggleInstanceDirection() {
	    var direction = instance.direction;

	    if (direction !== 'alternate') {
	      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
	    }

	    instance.reversed = !instance.reversed;
	    children.forEach(function (child) {
	      return child.reversed = instance.reversed;
	    });
	  }

	  function adjustTime(time) {
	    return instance.reversed ? instance.duration - time : time;
	  }

	  function resetTime() {
	    startTime = 0;
	    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
	  }

	  function seekChild(time, child) {
	    if (child) {
	      child.seek(time - child.timelineOffset);
	    }
	  }

	  function syncInstanceChildren(time) {
	    if (!instance.reversePlayback) {
	      for (var i = 0; i < childrenLength; i++) {
	        seekChild(time, children[i]);
	      }
	    } else {
	      for (var i$1 = childrenLength; i$1--;) {
	        seekChild(time, children[i$1]);
	      }
	    }
	  }

	  function setAnimationsProgress(insTime) {
	    var i = 0;
	    var animations = instance.animations;
	    var animationsLength = animations.length;

	    while (i < animationsLength) {
	      var anim = animations[i];
	      var animatable = anim.animatable;
	      var tweens = anim.tweens;
	      var tweenLength = tweens.length - 1;
	      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

	      if (tweenLength) {
	        tween = filterArray(tweens, function (t) {
	          return insTime < t.end;
	        })[0] || tween;
	      }

	      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
	      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
	      var strings = tween.to.strings;
	      var round = tween.round;
	      var numbers = [];
	      var toNumbersLength = tween.to.numbers.length;
	      var progress = void 0;

	      for (var n = 0; n < toNumbersLength; n++) {
	        var value = void 0;
	        var toNumber = tween.to.numbers[n];
	        var fromNumber = tween.from.numbers[n] || 0;

	        if (!tween.isPath) {
	          value = fromNumber + eased * (toNumber - fromNumber);
	        } else {
	          value = getPathProgress(tween.value, eased * toNumber);
	        }

	        if (round) {
	          if (!(tween.isColor && n > 2)) {
	            value = Math.round(value * round) / round;
	          }
	        }

	        numbers.push(value);
	      } // Manual Array.reduce for better performances


	      var stringsLength = strings.length;

	      if (!stringsLength) {
	        progress = numbers[0];
	      } else {
	        progress = strings[0];

	        for (var s = 0; s < stringsLength; s++) {
	          var a = strings[s];
	          var b = strings[s + 1];
	          var n$1 = numbers[s];

	          if (!isNaN(n$1)) {
	            if (!b) {
	              progress += n$1 + ' ';
	            } else {
	              progress += n$1 + b;
	            }
	          }
	        }
	      }

	      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
	      anim.currentValue = progress;
	      i++;
	    }
	  }

	  function setCallback(cb) {
	    if (instance[cb] && !instance.passThrough) {
	      instance[cb](instance);
	    }
	  }

	  function countIteration() {
	    if (instance.remaining && instance.remaining !== true) {
	      instance.remaining--;
	    }
	  }

	  function setInstanceProgress(engineTime) {
	    var insDuration = instance.duration;
	    var insDelay = instance.delay;
	    var insEndDelay = insDuration - instance.endDelay;
	    var insTime = adjustTime(engineTime);
	    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
	    instance.reversePlayback = insTime < instance.currentTime;

	    if (children) {
	      syncInstanceChildren(insTime);
	    }

	    if (!instance.began && instance.currentTime > 0) {
	      instance.began = true;
	      setCallback('begin');
	    }

	    if (!instance.loopBegan && instance.currentTime > 0) {
	      instance.loopBegan = true;
	      setCallback('loopBegin');
	    }

	    if (insTime <= insDelay && instance.currentTime !== 0) {
	      setAnimationsProgress(0);
	    }

	    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
	      setAnimationsProgress(insDuration);
	    }

	    if (insTime > insDelay && insTime < insEndDelay) {
	      if (!instance.changeBegan) {
	        instance.changeBegan = true;
	        instance.changeCompleted = false;
	        setCallback('changeBegin');
	      }

	      setCallback('change');
	      setAnimationsProgress(insTime);
	    } else {
	      if (instance.changeBegan) {
	        instance.changeCompleted = true;
	        instance.changeBegan = false;
	        setCallback('changeComplete');
	      }
	    }

	    instance.currentTime = minMax(insTime, 0, insDuration);

	    if (instance.began) {
	      setCallback('update');
	    }

	    if (engineTime >= insDuration) {
	      lastTime = 0;
	      countIteration();

	      if (!instance.remaining) {
	        instance.paused = true;

	        if (!instance.completed) {
	          instance.completed = true;
	          setCallback('loopComplete');
	          setCallback('complete');

	          if (!instance.passThrough && 'Promise' in window) {
	            resolve();
	            promise = makePromise(instance);
	          }
	        }
	      } else {
	        startTime = now;
	        setCallback('loopComplete');
	        instance.loopBegan = false;

	        if (instance.direction === 'alternate') {
	          toggleInstanceDirection();
	        }
	      }
	    }
	  }

	  instance.reset = function () {
	    var direction = instance.direction;
	    instance.passThrough = false;
	    instance.currentTime = 0;
	    instance.progress = 0;
	    instance.paused = true;
	    instance.began = false;
	    instance.loopBegan = false;
	    instance.changeBegan = false;
	    instance.completed = false;
	    instance.changeCompleted = false;
	    instance.reversePlayback = false;
	    instance.reversed = direction === 'reverse';
	    instance.remaining = instance.loop;
	    children = instance.children;
	    childrenLength = children.length;

	    for (var i = childrenLength; i--;) {
	      instance.children[i].reset();
	    }

	    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
	      instance.remaining++;
	    }

	    setAnimationsProgress(instance.reversed ? instance.duration : 0);
	  }; // Set Value helper


	  instance.set = function (targets, properties) {
	    setTargetsValue(targets, properties);
	    return instance;
	  };

	  instance.tick = function (t) {
	    now = t;

	    if (!startTime) {
	      startTime = now;
	    }

	    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
	  };

	  instance.seek = function (time) {
	    setInstanceProgress(adjustTime(time));
	  };

	  instance.pause = function () {
	    instance.paused = true;
	    resetTime();
	  };

	  instance.play = function () {
	    if (!instance.paused) {
	      return;
	    }

	    if (instance.completed) {
	      instance.reset();
	    }

	    instance.paused = false;
	    activeInstances.push(instance);
	    resetTime();

	    if (!raf) {
	      engine();
	    }
	  };

	  instance.reverse = function () {
	    toggleInstanceDirection();
	    resetTime();
	  };

	  instance.restart = function () {
	    instance.reset();
	    instance.play();
	  };

	  instance.reset();

	  if (instance.autoplay) {
	    instance.play();
	  }

	  return instance;
	} // Remove targets from animation


	function removeTargetsFromAnimations(targetsArray, animations) {
	  for (var a = animations.length; a--;) {
	    if (arrayContains(targetsArray, animations[a].animatable.target)) {
	      animations.splice(a, 1);
	    }
	  }
	}

	function removeTargets(targets) {
	  var targetsArray = parseTargets(targets);

	  for (var i = activeInstances.length; i--;) {
	    var instance = activeInstances[i];
	    var animations = instance.animations;
	    var children = instance.children;
	    removeTargetsFromAnimations(targetsArray, animations);

	    for (var c = children.length; c--;) {
	      var child = children[c];
	      var childAnimations = child.animations;
	      removeTargetsFromAnimations(targetsArray, childAnimations);

	      if (!childAnimations.length && !child.children.length) {
	        children.splice(c, 1);
	      }
	    }

	    if (!animations.length && !children.length) {
	      instance.pause();
	    }
	  }
	} // Stagger helpers


	function stagger(val, params) {
	  if (params === void 0) params = {};
	  var direction = params.direction || 'normal';
	  var easing = params.easing ? parseEasings(params.easing) : null;
	  var grid = params.grid;
	  var axis = params.axis;
	  var fromIndex = params.from || 0;
	  var fromFirst = fromIndex === 'first';
	  var fromCenter = fromIndex === 'center';
	  var fromLast = fromIndex === 'last';
	  var isRange = is.arr(val);
	  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
	  var val2 = isRange ? parseFloat(val[1]) : 0;
	  var unit = getUnit(isRange ? val[1] : val) || 0;
	  var start = params.start || 0 + (isRange ? val1 : 0);
	  var values = [];
	  var maxValue = 0;
	  return function (el, i, t) {
	    if (fromFirst) {
	      fromIndex = 0;
	    }

	    if (fromCenter) {
	      fromIndex = (t - 1) / 2;
	    }

	    if (fromLast) {
	      fromIndex = t - 1;
	    }

	    if (!values.length) {
	      for (var index = 0; index < t; index++) {
	        if (!grid) {
	          values.push(Math.abs(fromIndex - index));
	        } else {
	          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
	          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
	          var toX = index % grid[0];
	          var toY = Math.floor(index / grid[0]);
	          var distanceX = fromX - toX;
	          var distanceY = fromY - toY;
	          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

	          if (axis === 'x') {
	            value = -distanceX;
	          }

	          if (axis === 'y') {
	            value = -distanceY;
	          }

	          values.push(value);
	        }

	        maxValue = Math.max.apply(Math, values);
	      }

	      if (easing) {
	        values = values.map(function (val) {
	          return easing(val / maxValue) * maxValue;
	        });
	      }

	      if (direction === 'reverse') {
	        values = values.map(function (val) {
	          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
	        });
	      }
	    }

	    var spacing = isRange ? (val2 - val1) / maxValue : val1;
	    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
	  };
	} // Timeline


	function timeline(params) {
	  if (params === void 0) params = {};
	  var tl = anime(params);
	  tl.duration = 0;

	  tl.add = function (instanceParams, timelineOffset) {
	    var tlIndex = activeInstances.indexOf(tl);
	    var children = tl.children;

	    if (tlIndex > -1) {
	      activeInstances.splice(tlIndex, 1);
	    }

	    function passThrough(ins) {
	      ins.passThrough = true;
	    }

	    for (var i = 0; i < children.length; i++) {
	      passThrough(children[i]);
	    }

	    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
	    insParams.targets = insParams.targets || params.targets;
	    var tlDuration = tl.duration;
	    insParams.autoplay = false;
	    insParams.direction = tl.direction;
	    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
	    passThrough(tl);
	    tl.seek(insParams.timelineOffset);
	    var ins = anime(insParams);
	    passThrough(ins);
	    children.push(ins);
	    var timings = getInstanceTimings(children, params);
	    tl.delay = timings.delay;
	    tl.endDelay = timings.endDelay;
	    tl.duration = timings.duration;
	    tl.seek(0);
	    tl.reset();

	    if (tl.autoplay) {
	      tl.play();
	    }

	    return tl;
	  };

	  return tl;
	}

	anime.version = '3.1.0';
	anime.speed = 1;
	anime.running = activeInstances;
	anime.remove = removeTargets;
	anime.get = getOriginalTargetValue;
	anime.set = setTargetsValue;
	anime.convertPx = convertPxToUnit;
	anime.path = getPath;
	anime.setDashoffset = setDashoffset;
	anime.stagger = stagger;
	anime.timeline = timeline;
	anime.easing = parseEasings;
	anime.penner = penner;

	anime.random = function (min, max) {
	  return Math.floor(Math.random() * (max - min + 1)) + min;
	};

	var _this2 = undefined;
	var _timeline = anime.timeline,
	    remove = anime.remove,
	    stagger$1 = anime.stagger,
	    random = anime.random;
	var _document$1 = document,
	    documentElement = _document$1.documentElement;
	var Ele;
	var tagRE = /^\s*<(\w+|!)[^>]*>/;
	var applyNative = _event.applyNative,
	    nativeEvents = _event.nativeEvents;
	var tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig;
	var _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"];

	var _qsa = function _qsa() {
	  var dom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var sel = arguments.length > 1 ? arguments[1] : undefined;
	  var classes;
	  if (!_is.str(sel) && sel.length == 0) return [];

	  if (/^(#?[\w-]+|\.[\w-.]+)$/.test(sel)) {
	    switch (sel.charAt(0)) {
	      case '#':
	        return [dom.getElementById(sel.substr(1))];

	      case '.':
	        classes = sel.substr(1).replace(/\./g, ' ');
	        return _toConsumableArray(dom.getElementsByClassName(classes));

	      default:
	        return _toConsumableArray(dom.getElementsByTagName(sel));
	    }
	  }

	  return _toConsumableArray(dom.querySelectorAll(sel));
	}; // The matches() method checks to see if the Element would be selected by the provided selectorString -- in other words -- checks if the element "is" the selector.


	var _matches = function _matches(ele, sel) {
	  var matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
	  if (matchSel) return matchSel.call(ele, sel);
	}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.


	var _contains = function _contains(parent, node) {
	  if (parent.contains) return parent != node && parent.contains(node);

	  while (node && (node = node.parentNode)) {
	    if (node == parent) return true;
	  }

	  return false;
	}; // Support the Element Object as an Array


	var _toArr = function _toArr(val) {
	  return _is.inst(val, Ele) ? val.toArray() : val;
	};

	var _concat = function _concat(args) {
	  [].map.call(args, function (val) {
	    return _toArr(val);
	  });
	  return [].concat.apply(_toArr(this), args);
	}; // Create a flat Array


	var _flatten = function _flatten(arr) {
	  return arr.length > 0 ? _concat.apply([], arr) : arr;
	}; // Map Objects


	var _map = function _map(obj, fn, ctxt) {
	  return _flatten([].map.call(obj, fn, ctxt).filter(function (item) {
	    return _is.def(item);
	  }));
	}; // Select all children of an element


	var _children = function _children(el) {
	  return 'children' in el ? [].slice.call(el.children) : _map(el.childNodes, function (node) {
	    if (node.nodeType == 1) return node;
	  });
	}; // Class name cache


	var _cache = {}; // Get the class name for an Element

	var _getclass = function classNme(node, value) {
	  var name = node.className || '';
	  var svg = name && !_is.undef(name.baseVal);
	  if (_is.undef(value)) return svg ? name.baseVal : name;
	  svg ? name.baseVal = value : node.className = value;
	}; // Class name RegExp


	var _classRE = function _classRE(name) {
	  return name in _cache ? _cache[name] : _cache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
	}; // Create an Element List from a HTML string


	var _createElem = function _createElem(html) {
	  var dom, container;
	  container = document.createElement('div');
	  container.innerHTML = '' + html.replace(tagExpandRE, "<$1></$2>");
	  dom = [].slice.call(container.childNodes);
	  dom.forEach(function (el) {
	    container.removeChild(el);
	  });
	  return dom;
	}; // Element selector


	var _elem = function _elem(sel, ctxt) {
	  if (_is.str(sel)) {
	    sel = sel.trim();

	    if (tagRE.test(sel)) {
	      return _createElem(sel);
	    } else {
	      return _qsa(ctxt, sel);
	    }
	  } else if (_is.inst(sel, Ele)) {
	    return sel.ele;
	  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
	    return _toConsumableArray(sel).filter(function (item) {
	      return _is.def(item);
	    });
	  } else if (_is.obj(sel) || _is.el(sel)) {
	    return [sel];
	  } else if (_is.fn(sel)) {
	    Ele(document).ready(sel);
	  }

	  return [];
	}; // Traverse DOM Depth First


	var traverseDF = function traverseDF(_node, fn) {
	  var childType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "childNodes";

	  var _recurse; // This is a recurse and immediately-invoking function


	  _recurse = function recurse(node) {
	    // Step 2
	    node[childType] && node[childType].forEach(_recurse, node); // Step 3

	    fn.call(node, node); // Step 4
	  };

	  _recurse(_node); // Step 1

	}; // Quickly filter nodes by a selector


	var _filter = function _filter(nodes, sel) {
	  return !_is.def(sel) ? Ele(nodes) : Ele(nodes).filter(sel);
	}; // Select all the different values in an Array, based on underscorejs


	var _uniq = function _uniq(arr) {
	  return [].filter.call(arr, function (val, idx) {
	    return arr.indexOf(val) == idx;
	  });
	}; // Quickly set the value of an attribute or remove the attribute completely from a node


	var _setAttr = function _setAttr(node, name, value) {
	  return value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
	}; // Transform  string value to the proper type of value eg. "12" = 12, "[12, 'xyz']" = [12, 'xyz']


	var _valfix = function _valfix(value) {
	  var validTypes = /^true|false|null|undefined|\d+$/;

	  var _fn = function _fn(v) {
	    return Function("\"use strict\"; return ".concat(v, ";"))();
	  };

	  var objectType = /^[[{]([\s\S]+)?[\]}]$/;

	  try {
	    return validTypes.test(value) ? _fn(value) : objectType.test(value) ? JSON.parse(value.replace(/'/g, "\"")) : value;
	  } catch (e) {
	    return value;
	  }
	}; // Decide if the value deserves px at the


	var _maybeAddPx = function _maybeAddPx(name, val) {
	  return _is.num(+val) && !_cssNumber.includes(name) ? "".concat(val, "px") : val;
	}; // Allow default Array methods to work as Element Object methods


	var arrProto = Object.getOwnPropertyNames(Array.prototype).reduce(function (acc, i) {
	  acc[i] = function () {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var _val = Array.prototype[i].apply(this, args);

	    return _is.undef(_val) ? this : _val;
	  };

	  return acc;
	}, {}); // Element Object [Based on Zepto.js]

	Ele = _event.extend(arrProto, {
	  init: function init() {
	    var sel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var ctxt = arguments.length > 1 ? arguments[1] : undefined;
	    this.sel = sel; // Selector

	    this.ele = _elem(this.sel, ctxt); // Element

	    for (var i = 0; i < this.length; i++) {
	      this[i] = this.ele[i];
	    }
	  },
	  slice: function slice() {
	    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }

	    return Ele([].slice.apply(this, args));
	  },
	  map: function map(fn) {
	    return Ele(_map(this, function (el, i) {
	      return fn.call(el, el, i);
	    }, this));
	  },
	  on: function on($super, evt, callback, scope) {
	    var _this = this;

	    var _newEvts, _evt;

	    if (_is.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is.not("arr", evt) && _is.not("obj", evt)) {
	      evt = [evt];
	    } // Set evt to an array


	    _evt = _is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt;
	    _newEvts = _evt.filter(function (val) {
	      return !(val in _this._events);
	    }, this).join(" ");
	    this.forEach(function (el, i) {
	      $super(evt, callback, scope || el);
	      applyNative(this, el, _newEvts, i);
	    }, this);
	    return this;
	  },
	  off: function off($super, evt, callback, scope) {
	    var _evt;

	    if (_is.undef(evt)) {
	      return;
	    } // If there is no event break


	    if (_is.str(evt)) {
	      evt = evt.split(/\s/g);
	    }

	    if (_is.not("arr", evt) && _is.not("obj", evt)) {
	      evt = [evt];
	    } // Set evt to an array


	    _evt = (_is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt).join(" ");
	    this.forEach(function (el, i) {
	      $super(evt, callback, scope || el);
	      applyNative(this, el, _evt, i, "removeEventListener");
	    }, this);
	    return this;
	  },
	  length: _get("len"),
	  len: _get("ele.length"),
	  each: function each(fn) {
	    [].every.call(this, function (el, idx) {
	      return fn.call(el, el, idx) != false;
	    });
	    return this;
	  },
	  get: function get(idx) {
	    return _is.undef(idx) ? [].slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
	  },
	  nth: _get("get"),
	  size: function size() {
	    return this.length;
	  },
	  toArray: function toArray() {
	    return this.get();
	  },
	  remove: function remove() {
	    return this.each(function (el) {
	      if (_is.def(el.parentNode)) ;
	      el.parentNode.removeChild(el);
	    });
	  },
	  not: function not(sel) {
	    var excludes,
	        $this = this;
	    return Ele(this.reduce(function (acc, el, idx) {
	      if (_is.fn(sel) && _is.def(sel.call)) {
	        if (!sel.call(el, el, idx)) acc.push(el);
	      } else {
	        excludes = _is.str(sel) ? $this.filter(sel) : _is.arrlike(sel) && _is.fn(sel.item) ? [].slice.call(sel) : Ele(sel);
	        if (excludes.indexOf(el) < 0) acc.push(el);
	      }

	      return acc;
	    }, [], this));
	  },
	  filter: function filter(sel) {
	    if (_is.fn(sel)) return this.not(this.not(sel));
	    return [].filter.call(this, function (ele) {
	      return _matches(ele, sel);
	    }, this);
	  },
	  has: function has(sel) {
	    return this.filter(function (el) {
	      return _is.obj(sel) ? _contains(el, sel) : Ele(el).find(sel).size();
	    });
	  },
	  eq: function eq(idx) {
	    return idx == -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
	  },
	  first: function first() {
	    var el = this.get(0);
	    return el && !_is.obj(el) ? el : Ele(el);
	  },
	  last: function last() {
	    var el = this.get(-1);
	    return el && !_is.obj(el) ? el : Ele(el);
	  },
	  find: function find(sel) {
	    var result,
	        $this = this;
	    if (!sel) result = Ele();else if (_is.obj(sel)) {
	      result = Ele(sel).filter(function (el) {
	        return [].some.call($this, function (parent) {
	          return _contains(parent, el);
	        });
	      });
	    } else if (this.length == 1) {
	      result = Ele(_qsa(this.get(0), sel));
	    } else {
	      result = this.map(function (el) {
	        return _qsa(el, sel);
	      });
	    }
	    return result;
	  },
	  closest: function closest(sel, ctxt) {
	    var list = _is.obj(sel) && Ele(sel);
	    return Ele(this.reduce(function (acc, ele) {
	      do {
	        if (list ? list.indexOf(ele) >= 0 : _matches(ele, sel)) break;
	        ele = ele != ctxt && _is.not("doc", ele) && ele.parentNode;
	      } while (ele !== null && ele.nodeType === 1);

	      if (ele && acc.indexOf(ele) < 0) acc.push(ele);
	      return acc;
	    }, []));
	  },
	  parents: function parents(sel) {
	    var ancestors = [],
	        nodes = this;

	    while (nodes.length > 0) {
	      nodes = nodes.map(function (el) {
	        if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {
	          ancestors.push(el);
	          return el;
	        }
	      });
	    }

	    return _filter(ancestors, sel);
	  },
	  // `pluck` based on underscore.js, but way more powerful
	  pluck: function pluck(prop) {
	    return this.map(function (el) {
	      return _path(el, prop);
	    });
	  },
	  parent: function parent(sel) {
	    return _filter(_uniq(this.pluck('parentNode')), sel);
	  },
	  children: function children(sel) {
	    return _filter(this.map(function (el) {
	      return _children(el);
	    }), sel);
	  },
	  contents: function contents() {
	    return this.map(function (el) {
	      return el.contentDocument || [].slice.call(el.childNodes);
	    });
	  },
	  siblings: function siblings(sel) {
	    return _filter(this.map(function (el) {
	      return [].filter.call(_children(el.parentNode), function (child) {
	        return child != el;
	      });
	    }), sel);
	  },
	  replaceWith: function replaceWith(content) {
	    return _this2.before(content).remove();
	  },
	  clone: function clone() {
	    return _this2.map(function (el) {
	      return el.cloneNode(true);
	    });
	  },
	  toggle: function toggle(opt) {
	    return this.each(function (el) {
	      var _el = Ele(el);

	      var _opt = opt || el.style("display") == "none";

	      _el[_opt ? "show" : "hide"]();
	    });
	  },
	  prev: function prev(sel) {
	    return Ele(_this2.pluck('previousElementSibling')).filter(sel || '*');
	  },
	  next: function next(sel) {
	    return Ele(_this2.pluck('nextElementSibling')).filter(sel || '*');
	  },
	  html: function html() {
	    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      args[_key3] = arguments[_key3];
	    }

	    var html = args[0];
	    return args.length ? this.each(function (el, idx) {
	      var originHTML = el.innerHTML;
	      Ele(el).empty().append(_fnval(html, [idx, originHTML], el));
	    }) : this.length ? this.get(0).innerHTML : null;
	  },
	  text: function text() {
	    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      args[_key4] = arguments[_key4];
	    }

	    var text = args[0];
	    return args.length ? this.each(function (el, idx) {
	      var newText = _fnval(text, [idx, el.textContent], el);

	      el.textContent = _is.nul(newText) ? '' : "".concat(newText);
	    }) : this.length ? this.pluck('textContent').join("") : null;
	  },
	  attr: function attr(name, val) {
	    var result;

	    if (_is.str(name) && _is.undef(val)) {
	      result = this.length && this.get(0).nodeType == 1 && this.get(0).getAttribute(name);
	      return !_is.nul(result) ? result : undefined;
	    } else {
	      return this.each(function (el, idx) {
	        if (el.nodeType != 1) return;

	        if (_is.arr(name)) {
	          for (var i in name) {
	            _setAttr(el, i, name[i]);
	          }
	        } else {
	          _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));
	        }
	      });
	    }
	  },
	  removeAttr: function removeAttr(name) {
	    return this.each(function (el) {
	      el.nodeType == 1 && name.split(' ').forEach(function (attr) {
	        _setAttr(el, attr);
	      });
	    });
	  },
	  data: function data(name, value) {
	    var attrName = "data-".concat(name).toLowerCase();
	    var data = _is.def(value) ? this.attr(attrName, value) : this.attr(attrName);
	    return data != null ? _valfix(data) : undefined;
	  },
	  val: function val() {
	    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      args[_key5] = arguments[_key5];
	    }

	    var value = args[0],
	        _el;

	    if (args.length) {
	      if (_is.nul(value)) value = "";
	      return this.each(function (el, idx) {
	        el.value = _fnval(value, [idx, el.value], el);
	      });
	    } else {
	      _el = this.get(0);
	      return _el && (_el.multiple ? Ele(_el).find('option').filter(function (el) {
	        return el.selected;
	      }).pluck('value') : _el.value);
	    }
	  },
	  offset: function offset(coords) {
	    var obj;

	    if (coords) {
	      return this.each(function (el, idx) {
	        var $this = Ele(el);

	        var _coords = _fnval(coords, [idx, $this.offset()], el);

	        var parentOffset = $this.offsetParent().offset();
	        var props = {
	          top: _coords.top - parentOffset.top,
	          left: _coords.left - parentOffset.left
	        };
	        if ($this.style('position') == 'static') props.position = 'relative';
	        $this.style(props);
	      });
	    }

	    if (!this.length) return null;
	    if (documentElement != this.get(0) && !_contains(documentElement, this.get(0))) return {
	      top: 0,
	      left: 0
	    };
	    obj = this.get(0).getBoundingClientRect();
	    return {
	      left: obj.left + window.pageXOffset,
	      top: obj.top + window.pageYOffset,
	      width: Math.round(obj.width),
	      height: Math.round(obj.height)
	    };
	  },
	  style: function style() {
	    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	      args[_key6] = arguments[_key6];
	    }

	    var prop = args[0],
	        val = args[1],
	        css = '',
	        key;

	    if (args.length < 2) {
	      var el = this.get(0);
	      if (!el) return;

	      if (_is.str(prop)) {
	        return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
	      } else if (_is.arr(prop)) {
	        var props = {};
	        var computedStyle = window.getComputedStyle(el, '');
	        prop.forEach(function (_prop) {
	          props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
	        });
	        return props;
	      }
	    }

	    if (_is.str(prop)) {
	      if (!val && val != 0) {
	        this.each(function (el) {
	          el.style.removeProperty(prop);
	        });
	      } else {
	        css = prop + ":" + _maybeAddPx(prop, val);
	      }
	    } else {
	      for (key in prop) {
	        if (!prop[key] && prop[key] != 0) {
	          this.each(function (el) {
	            el.style.removeProperty(key);
	          });
	        } else {
	          css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
	        }
	      }
	    }

	    return this.each(function (el) {
	      el.style.cssText += ';' + css;
	    });
	  },
	  show: function show() {
	    return _this2.style("display", "");
	  },
	  hide: function hide() {
	    return _this2.style("display", "none");
	  },
	  empty: function empty() {
	    return _this2.each(function (el) {
	      el.innerHTML = '';
	    });
	  },
	  index: function index(el) {
	    return el ? this.indexOf(Ele(el).get(0)) : this.parent().children().indexOf(this.get(0));
	  },
	  hasClass: function hasClass(name) {
	    if (!name) return false;
	    return [].some.call(this, function (el) {
	      return this.test(_getclass(el));
	    }, _classRE(name));
	  },
	  addClass: function addClass(name) {
	    if (!name) return this;
	    return this.each(function (el, idx) {
	      if (!('className' in el)) return;

	      var classList = [],
	          cls = _getclass(el);

	      _fnval(name, [idx, cls], el).split(/\s+/g).forEach(function (_name) {
	        if (!Ele(this).hasClass(_name)) classList.push(_name);
	      }, el);

	      classList.length && _getclass(el, cls + (cls ? " " : "") + classList.join(" "));
	    });
	  },
	  removeClass: function removeClass(name) {
	    return this.each(function (el, idx) {
	      if (!('className' in el)) return;
	      if (_is.undef(name)) return _getclass(el, '');

	      var classList = _getclass(el);

	      _fnval(name, [idx, classList], el).split(/\s+/g).forEach(function (_name) {
	        classList = classList.replace(_classRE(_name), " ");
	      });

	      _getclass(el, classList.trim());
	    });
	  },
	  toggleClass: function toggleClass(name, when) {
	    if (!name) return this;
	    return this.each(function (el, idx) {
	      var $this = Ele(el);

	      _fnval(name, [idx, _getclass(el)], el).split(/\s+/g).forEach(function (_name) {
	        (_is.undef(when) ? !$this.hasClass(_name) : when) ? $this.addClass(_name) : $this.removeClass(_name);
	      });
	    });
	  },
	  scrollTop: function scrollTop(val) {
	    if (!this.length) return;
	    var hasScroll = 'scrollTop' in this.get(0);
	    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollTop" : "pageYOffset"];
	    return this.each(function () {
	      hasScroll ? this.scrollTop = val : this.scrollTo(this.scrollX, val);
	    });
	  },
	  scrollLeft: function scrollLeft(val) {
	    if (!this.length) return;
	    var hasScroll = 'scrollLeft' in this.get(0);
	    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollLeft" : "pageXOffset"];
	    return this.each(function () {
	      hasScroll ? this.scrollLeft = val : this.scrollTo(val, this.scrollY);
	    });
	  },
	  offsetParent: function offsetParent() {
	    return this.map(function (el) {
	      var parent = el.offsetParent || document.body;

	      while (parent && !/^(?:body|html)$/i.test(parent.nodeName) && Ele(parent).style("position") == "static") {
	        parent = parent.offsetParent;
	      }

	      return parent;
	    });
	  },
	  position: function position() {
	    if (!this.length) return;
	    var elem = this.get(0),
	        offsetParent = this.offsetParent(),
	        offset = this.offset(),
	        parentOffset = /^(?:body|html)$/i.test(offsetParent[0].nodeName) ? {
	      top: 0,
	      left: 0
	    } : offsetParent.offset();
	    offset.top -= parseFloat(Ele(elem).style('margin-top')) || 0;
	    offset.left -= parseFloat(Ele(elem).style('margin-left')) || 0;
	    parentOffset.top += parseFloat(Ele(offsetParent[0]).style('border-top-width')) || 0;
	    parentOffset.left += parseFloat(Ele(offsetParent[0]).style('border-left-width')) || 0;
	    return {
	      top: offset.top - parentOffset.top,
	      left: offset.left - parentOffset.left
	    };
	  },
	  getAnime: function getAnime() {
	    return this.anime;
	  },
	  timeline: function timeline() {
	    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    this.anime = _timeline(_objectSpread2({
	      targets: _toArr(this)
	    }, opt));
	    return this;
	  },
	  animate: function animate() {
	    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var offset = arguments.length > 1 ? arguments[1] : undefined;
	    opt = _fnval(opt, [{
	      stagger: stagger$1,
	      remove: remove,
	      random: random
	    }, offset], this);
	    _is.def(this.anime) && this.anime.add ? this.anime.add(opt, offset) : this.anime = anime(_objectSpread2({
	      targets: _toArr(this)
	    }, opt));
	    return this;
	  }
	}, // Generate shortforms for events eg. .click(), .hover(), etc...
	nativeEvents.reduce(function (acc, name) {
	  // Handle event binding
	  acc[name] = function () {
	    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
	      args[_key7] = arguments[_key7];
	    }

	    return this.on.apply(this, [name].concat(args));
	  };

	  return acc;
	}, {
	  hover: function hover(fnOver, fnOut) {
	    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
	  }
	}), // Generate the `width` and `height` methods
	['width', 'height'].reduce(function (acc, sz) {
	  var prop = _capital(sz);

	  acc[sz] = function (value) {
	    var offset,
	        el = this.get(0);

	    if (_is.undef(value)) {
	      if (_is.win(el)) {
	        return el["inner".concat(prop)];
	      } else if (_is.doc(el)) {
	        return el.documentElement["scroll".concat(prop)];
	      } else {
	        return (offset = this.offset()) && offset[sz];
	      }
	    } else {
	      return this.each(function (_el, idx) {
	        el = Ele(_el);
	        el.style(sz, _fnval(value, [idx, el[sz]()], _el));
	      });
	    }
	  };

	  return acc;
	}, {}), // Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
	['after', 'prepend', 'before', 'append'].reduce(function (acc, fn, idx) {
	  var inside = idx % 2; //=> prepend, append

	  acc[fn] = function () {
	    // Arguments can be nodes, arrays of nodes, Element objects and HTML strings
	    var clone = this.length > 1;

	    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
	      args[_key8] = arguments[_key8];
	    }

	    var nodes = _map(args, function (arg) {
	      if (_is.arr(arg)) {
	        return arg.reduce(function (acc, el) {
	          if (_is.def(el.nodeType)) acc.push(el);else if (_is.inst(el, Ele)) acc = acc.concat(el.get());else if (_is.str(el)) acc = acc.concat(_createElem(el));
	          return acc;
	        }, []);
	      }

	      return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);
	    });

	    return this.each(function (target) {
	      var parent = inside ? target : target.parentNode;

	      var parentInDoc = _contains(documentElement, parent);

	      var next = target.nextSibling,
	          first = target.firstChild; // Convert all methods to a "before" operation

	      target = [next, first, target, null][idx];
	      nodes.forEach(function (node) {
	        if (clone) node = node.cloneNode(true);else if (!parent) return Ele(node).remove();
	        parent.insertBefore(node, target);

	        if (parentInDoc) {
	          traverseDF(node, function (el) {
	            if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() == 'SCRIPT' && (!el.type || el.type == 'text/javascript') && !el.src) {
	              var _target = el.ownerDocument ? el.ownerDocument.defaultView : window;

	              _target.eval.call(_target, el.innerHTML);
	            }
	          });
	        }
	      });
	    });
	  }; // after    => insertAfter, prepend  => prependTo
	  // before   => insertBefore, append   => appendTo


	  acc[inside ? "".concat(fn, "To") : "insert".concat(_capital(fn))] = function (html) {
	    Ele(html)[fn](this);
	    return this;
	  };

	  return acc;
	}, {}));
	var el = Ele;

	var lib$1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var Plugin = function () {
	    function Plugin() {
	      _classCallCheck(this, Plugin);

	      this.isSwupPlugin = true;
	    }

	    _createClass(Plugin, [{
	      key: "mount",
	      value: function mount() {// this is mount method rewritten by class extending
	        // and is executed when swup is enabled with plugin
	      }
	    }, {
	      key: "unmount",
	      value: function unmount() {// this is unmount method rewritten by class extending
	        // and is executed when swup with plugin is disabled
	      }
	    }, {
	      key: "_beforeMount",
	      value: function _beforeMount() {// here for any future hidden auto init
	      }
	    }, {
	      key: "_afterUnmount",
	      value: function _afterUnmount() {} // here for any future hidden auto-cleanup
	      // this is here so we can tell if plugin was created by extending this class

	    }]);

	    return Plugin;
	  }();

	  exports["default"] = Plugin;
	});
	unwrapExports(lib$1);

	var DOCUMENT_NODE_TYPE$1 = 9;
	/**
	 * A polyfill for Element.matches()
	 */

	if (typeof Element !== 'undefined' && !Element.prototype.matches) {
	  var proto$1 = Element.prototype;
	  proto$1.matches = proto$1.matchesSelector || proto$1.mozMatchesSelector || proto$1.msMatchesSelector || proto$1.oMatchesSelector || proto$1.webkitMatchesSelector;
	}
	/**
	 * Finds the closest parent that matches a selector.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @return {Function}
	 */


	function closest$1(element, selector) {
	  while (element && element.nodeType !== DOCUMENT_NODE_TYPE$1) {
	    if (typeof element.matches === 'function' && element.matches(selector)) {
	      return element;
	    }

	    element = element.parentNode;
	  }
	}

	var closest_1$1 = closest$1;

	/**
	 * Delegates event to a selector.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @param {String} type
	 * @param {Function} callback
	 * @param {Boolean} useCapture
	 * @return {Object}
	 */

	function _delegate(element, selector, type, callback, useCapture) {
	  var listenerFn = listener$1.apply(this, arguments);
	  element.addEventListener(type, listenerFn, useCapture);
	  return {
	    destroy: function destroy() {
	      element.removeEventListener(type, listenerFn, useCapture);
	    }
	  };
	}
	/**
	 * Delegates event to a selector.
	 *
	 * @param {Element|String|Array} [elements]
	 * @param {String} selector
	 * @param {String} type
	 * @param {Function} callback
	 * @param {Boolean} useCapture
	 * @return {Object}
	 */


	function delegate$1(elements, selector, type, callback, useCapture) {
	  // Handle the regular Element usage
	  if (typeof elements.addEventListener === 'function') {
	    return _delegate.apply(null, arguments);
	  } // Handle Element-less usage, it defaults to global delegation


	  if (typeof type === 'function') {
	    // Use `document` as the first parameter, then apply arguments
	    // This is a short way to .unshift `arguments` without running into deoptimizations
	    return _delegate.bind(null, document).apply(null, arguments);
	  } // Handle Selector-based usage


	  if (typeof elements === 'string') {
	    elements = document.querySelectorAll(elements);
	  } // Handle Array-like based usage


	  return Array.prototype.map.call(elements, function (element) {
	    return _delegate(element, selector, type, callback, useCapture);
	  });
	}
	/**
	 * Finds closest match and invokes callback.
	 *
	 * @param {Element} element
	 * @param {String} selector
	 * @param {String} type
	 * @param {Function} callback
	 * @return {Function}
	 */


	function listener$1(element, selector, type, callback) {
	  return function (e) {
	    e.delegateTarget = closest_1$1(e.target, selector);

	    if (e.delegateTarget) {
	      callback.call(element, e);
	    }
	  };
	}

	var delegate_1$1 = delegate$1;

	var lib$2 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  var _plugin2 = _interopRequireDefault(lib$1);

	  var _delegate2 = _interopRequireDefault(delegate_1$1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PreloadPlugin = function (_Plugin) {
	    _inherits(PreloadPlugin, _Plugin);

	    function PreloadPlugin() {
	      var _ref;

	      var _temp, _this, _ret;

	      _classCallCheck(this, PreloadPlugin);

	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = PreloadPlugin.__proto__ || Object.getPrototypeOf(PreloadPlugin)).call.apply(_ref, [this].concat(args))), _this), _this.name = "PreloadPlugin", _this.onContentReplaced = function () {
	        _this.swup.preloadPages();
	      }, _this.onMouseover = function (event) {
	        var swup = _this.swup;
	        swup.triggerEvent('hoverLink', event);
	        var link = new helpers.Link(event.delegateTarget);

	        if (link.getAddress() !== (0, helpers.getCurrentUrl)() && !swup.cache.exists(link.getAddress()) && swup.preloadPromise == null) {
	          swup.preloadPromise = swup.preloadPage(link.getAddress());
	          swup.preloadPromise.route = link.getAddress();
	          swup.preloadPromise["finally"](function () {
	            swup.preloadPromise = null;
	          });
	        }
	      }, _this.preloadPage = function (pathname) {
	        var swup = _this.swup;
	        var link = new helpers.Link(pathname);
	        return new Promise(function (resolve, reject) {
	          if (link.getAddress() != (0, helpers.getCurrentUrl)() && !swup.cache.exists(link.getAddress())) {
	            (0, helpers.fetch)({
	              url: link.getAddress(),
	              headers: swup.options.requestHeaders
	            }, function (response) {
	              if (response.status === 500) {
	                swup.triggerEvent('serverError');
	                reject();
	              } else {
	                // get json data
	                var page = swup.getPageData(response);

	                if (page != null) {
	                  page.url = link.getAddress();
	                  swup.cache.cacheUrl(page, swup.options.debugMode);
	                  swup.triggerEvent('pagePreloaded');
	                } else {
	                  reject(link.getAddress());
	                  return;
	                }

	                resolve(swup.cache.getPage(link.getAddress()));
	              }
	            });
	          } else {
	            resolve(swup.cache.getPage(link.getAddress()));
	          }
	        });
	      }, _this.preloadPages = function () {
	        (0, utils.queryAll)('[data-swup-preload]').forEach(function (element) {
	          _this.swup.preloadPage(element.href);
	        });
	      }, _temp), _possibleConstructorReturn(_this, _ret);
	    }

	    _createClass(PreloadPlugin, [{
	      key: 'mount',
	      value: function mount() {
	        var swup = this.swup;
	        swup._handlers.pagePreloaded = [];
	        swup._handlers.hoverLink = [];
	        swup.preloadPage = this.preloadPage;
	        swup.preloadPages = this.preloadPages; // register mouseover handler

	        swup.delegatedListeners.mouseover = (0, _delegate2["default"])(document.body, swup.options.linkSelector, 'mouseover', this.onMouseover.bind(this)); // initial preload of page form links with [data-swup-preload]

	        swup.preloadPages(); // do the same on every content replace

	        swup.on('contentReplaced', this.onContentReplaced);
	      }
	    }, {
	      key: 'unmount',
	      value: function unmount() {
	        var swup = this.swup;
	        swup._handlers.pagePreloaded = null;
	        swup._handlers.hoverLink = null;
	        swup.preloadPage = null;
	        swup.preloadPages = null;
	        swup.delegatedListeners.mouseover.destroy();
	        swup.off('contentReplaced', this.onContentReplaced);
	      }
	    }]);

	    return PreloadPlugin;
	  }(_plugin2["default"]);

	  exports["default"] = PreloadPlugin;
	});
	var preload = unwrapExports(lib$2);

	var _load = function _load() {
	  var ele = el("<a class='name'>Hello</a>");
	  ele.prependTo("#swup");
	  ele.on("click", function () {
	    _log(this);

	    el(this).animate({
	      direction: 'alternate',
	      color: ["#008000", "#00eeaa"],
	      translateX: [0, 250]
	    });
	  });
	  el('main').find("a.name").on("click mouseenter", function () {
	    _log("Link - Hover/Clicked");
	  });
	};

	var trans = new swup({
	  requestHeaders: {
	    "X-Requested-With": "swup",
	    // So we can tell request comes from swup
	    "x-partial": "swup" // Request a partial html page

	  },
	  plugins: [new preload()]
	});

	_load(); // this event runs for every page view after initial load


	trans.on('contentReplaced', _load);

}));

//# sourceMappingURL=/maps/app.min.js.map
